The code here related to checking 32-bit integers to test for primality. The
ideas used come from the paper:
"Fast Primality Testing for Integers That Fit into a Machine Word"
by Michal Forisek and Jakub Jancina.

The files FJ32_256.cc and FJ64_16k.cc are unaltered versions of code
that their paper points to. The first uses a table of 256 16-bit witnesses to
provide a one-M-R check for 32-bit values, the second has a much larger
table and uses 3 M-R checks to test 64-bit inputs.
They have an alternative version of the 64-bit code that can get away with
just two Miller Rabin calculations, but that uses a much larger table.
I have not investigated the 64-bit case in my investigations.

To test 32-bit integers what F&J suggest is to start by filtering using
test division by 2, 3, 5 and 7. It the input passes those tests then a
hash function is used to map it onto an index in the range 0:N where N is
of the order of 256. This is used to access a table, and the table contains
16-bit values that are used as witnesses with Miller Rabin. If the hash
function and table are set up carefully one can ensure that Miller Rabin
never hits a strong pseudo-prime. In other words the hash table is used
to select witnesses that are reliable. They also have a 32-bit checker using
a tavle size of just 224, but that is a table of full sized rather than 16
bit integers, and one using a table of 1024 8-bit values.

My code here re-creates the 32-bit version of the F-J idea.

The program mr2a.cpp works through potential witness values and for each it
tabulates all the corresponding pseudo-primes to to 2^32. There are typically
about 2000 of these for each witness. The code uses multiple threads so that
it exploits multi-cored CPUs. In 2017 I ran this for about 2 months on an
8-core system to collect a 1.2 Gbyte file listing all strong pseudo-primes
up to 2^32 for every witness to beyond 0x10000. The data generated is the
input for the next stage. Future work may involve adapting the code to be able to
exploit GUI computational power. There is a good practical benefit in
considerating witnesses up to 16 bits in that they pack neatly in an array of
uint16_t. The next easy size up would be 32-bits, but mapping the pseudo-
primes for all witnesses up to 2^32 is a long way from realistic for me.

The program hash.cpp takes a succession on randomly selected hash functions
from a rather simple family, and in each case checks if it is possible to
use that function to set up a table that will support fast prime checking.
Forisek and Jancina note that finding a table of size 256 is fairly easy, and
that the smallest table they were able to create had 224 entries, but that
one had larger witness values stored in it and so the table had to be one
made of 32-bit integers rather than 16 bit ones.

At the time of writing this note I have found a table of size 225 16-bit
integers, and I will do a bit more experimenting using long test runs to see
if I can shrink that slightly, but at present it looks as if is close to
the limit. This provides a slightly more compact table than the one used
by F-J, and a very simple hash function. The improvement will not be
significant in any real context, but it has been good to reproduce their
work and find even a tiny enhancement.

Arthur Norman

