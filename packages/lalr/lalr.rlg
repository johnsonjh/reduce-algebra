% Test cases for the parser generator. This all runs in symbolic mode...


%
% This is where (for now) I will put documentation of the syntax I
% will use when creating a grammer. There is a main function called
% lalr_create_parser and that is passed a list that describes
% a grammar. It is in the form of a sequence of productions, and the first
% one given is taken to be the top-level target.
%
% Each production is in the form
%     (LHS   ((rhs1.1 rhs1.2 ...) a1.1 a1.2 ...)
%            ((rhs2.1 rhs2.1 ...) a2.1 a2.2 ...)
%            ...)
% which in regular publication style for grammars might be interpreted
% as meaning
%      LHS ::= rhs1.1 rhs1.2 ... { a1.1 a1.2 ... }
%          |   rhs2.1 rhs2.2 ... { a2.1 a2.2 ... }
%          ...
%          ;
%
% Each LHS is treated as a non-terminal symbol and is specified as a simple
% name. Note that by default the Reduce parser will be folding characters
% within names to lower case and so it will be best to choose names for
% non-terminals that are unambiguous even when case-folded, but I would like
% to establish a convention that in source code they are written in capitals.
%
% The rhs items may be either non-terminals (identified because they are
% present in the left hand side of some production) or terminals. Terminal
% symbols can be specified in two different ways.
% The lexer has built-in recipies that decode certain sequences of characters
% and return the special markers for !:symbol, !:number, !:string, !:list for
% commonly used cases. In these cases the variable yylval gets left set
% to associated data, so for instance in the case of !:symbol it gets set
% to the particular symbol concerned.
% The token type :list is used for Lisp or rlisp-like notation where the
% input contains
%     'expression
% or  `expression
% so for instance the input `(a b c) leads to the lexer returning !:list and
% yylvel being set to (backquote (a b c)). This treatment is specialised for
% handling rlisp-like syntax.
%
% Other terminals are indicated by writing a string. That may either
% consist of characters that would otherwise form a symbol (ie a letter
% followed by letters, digits and underscores) or a sequence of
% non-alphanumeric characters. In the latter case if a sequence of three or
% more punctuation marks make up a terminal then all the shorter prefixes
% of it will also be grouped to form single entities. So if "<-->" is a
% terminal then '<', '<-' and '<--' will each by parsed as single tokens, and
% any of them that are not used as terminals will be classified as !:symbol.
%
% As well as terminals and non-terminals (which are wrirrent as symbols or
% strings) it is possible to write one of
%     (OPT s1 s2 ...)           0 or 1 instances of the sequence s1, ...
%     (STAR s1 s2 ...)          0, 1, 2, ... instances
%     (PLUS s1 s2 ...)          1, 2, 3, ... instances
%     (LIST sep s1 s2 ...)      like (STAR s1 s2 ...) but with the single
%                               item sep between each instance.
%     (LISTPLUS sep s1 ...)     like (PLUS s2 ...) but with sep interleaved.
%     (OR s1 s2 ...)            one or other of the tokens shown.
%
% When the lexer processes input it will return a numeric code that identifies
% the type of the item seen, so in a production one might write
%     (!:symbol ":=" EXPRESSION)
% and as it recognises the first two tokens the lexer will return a numeric
% code for !:symbol (and set yylval to the actual symbol as seen) and then
% a numeric code that it allocates for ":=". In the latter case it will
% also set yylval to the symbol !:!= in case that is useful.
%
% Precedence can be set using lalr_precedence. See examples lower down in this
% file.

% Limitations are
% (1) At present the parser generator will not cope with large grammars
%     because it does not merge rules promptly enough.
% (2) The lexer is hand-written and can not readily be reconfigured for
%     use with languages other than rlisp. For instance it has use of "!"
%     as a character escape built into it.
%
%


symbolic;


nil


% Before testing parser generation I will demonstrate the lexer..
% If I was jumpy about the exact behaviour of the lexer I could go
%               on tracelex;
% to get some more tracing.

lex_cleanup();


nil


lex_keywords '("begin" "<=>" "<==");


nil


% The output from this is expected to be

%  Result: (2 symbol)
%  Result: (4 200)
%  Result: (4 3.542)
%  Result: (3 "a string")
%  Result: (2 nil)
%  Result: (5 (quote (quoted lisp)))
%  Result: (5 (backquote (backquoted (!, comma) (!,!@ comma_at))))
%  Result: (2 !+)
%  Result: (7 !<!=!>)
%  Result: (2 !-)
%  Result: (2 !=)
%  Result: (2 !>)
%  Result: (9 !<)
%  Result: (8 !<!=)
%  Result: (5 begin)
%  Result: (2 !;)
%  Result: (2 !;)
%  Result: (2 !;)
%
%  nil

% The row of "; ; ;" at the end provides some protection so that
% if faults in the lexer were to cause it to read more or less than it ought
% to then what is left over is reasonably likely to remain as valid rlisp
% syntax and so the rest of this test file will be able to continue happily.


<< off echo;
   lex_init();
   for i := 1:18 do <<
     tt := yylex();
     if not zerop posn() then terpri();
     princ "Result: ";
     print list(tt, yylval) >>;
   on echo >>;

Result: (1 symbol)
Result: (3 200)
Result: (3 3.542)
Result: (2 "a string")
Result: (4 (quote (quoted lisp)))
Result: (4 (backquote (backquoted (!, comma) (!,!@ comma_at))))
Result: (1 !+)
Result: (6 !<!=!>)
Result: (1 !-)
Result: (1 !=)
Result: (1 !>)
Result: (8 !<)
Result: (7 !<!=)
Result: (5 begin)
Result: (1 !;)
Result: (1 !;)
Result: (1 !;)
Result: (1 !;)

nil



on lalr_verbose;


nil


% Here I set up a sample grammar
%    S' -> S
%    S  -> C C        { }
%    C  -> "c" C      { }
%        | "d"        { }
% This is example 4.42 from Aho, Sethi and Ullman's Red Dragon book.
% It is example 4.54 in the more recent Purple book.

% Note that this grammar will introduce "c" and "d" as keywords rather than
% being general symbols. When I construct a subsequent grammar that will
% undo that setting. I will omit semantic actions here so that the default
% action of building a form of tree is used.

% There seems to be an issue here in that if I use a name for a non-terminal
% that is the same as one used for a terminal thinsg get confused. So I had
% originally hoped and expected to write just 'c' for the name of the
% non-terminal here are use '"c"' to denote the terminal. However when I
% try that I find that internally the names and up clashing to rather bad
% effect. I will look into this later since it is merely a matter of surface
% notation!  Also in the input to semantic actions the values passed when a
% terminal is matched may at present be the internal numeric code allocated
% to that terminal, not a "sensible" value. Agian this is a small issue.

grammar := '(
  (s  ((cc cc)  )   % One production for S, no explicit semantic here
  )
  (cc (("c" cc) (list 'c !$2))   % First production for C
      (("d")    'd           )   % Second production for C
  ));


((s ((cc cc))) (cc (("c" cc) (list (quote c) !$2)) (("d") (quote d))))


g := lalr_create_parser(nil, grammar);

=== Terminal symbols ===
   d [6]
   c [5]

"=== Nonterminal symbols ==="
[-1] S'             : S                         { nil }

[0] S               : CC CC                     { nil }

[1] CC              : d                         { ((quote d)) }
                    | c CC                      { ((list (quote c) !$2)) }


=== FIRST sets for each nonterminal ===
S':                 c d 
S:                  d c 
CC:                 c d 

=== LALR ITEMSET COLLECTION ===

Itemset 0
 S' -> . S [$]
 CC -> . d [c/d]
 CC -> . c CC [c/d]
 S -> . CC CC [$]
GOTO(S) = 1
GOTO(CC) = 2
GOTO(d) = 3
GOTO(c) = 4

Itemset 1
 S' -> S . [$]

Itemset 2
 CC -> . d [$]
 CC -> . c CC [$]
 S -> CC . CC [$]
GOTO(CC) = 6
GOTO(d) = 3
GOTO(c) = 4

Itemset 3
 CC -> d . [$/d/c]

Itemset 4
 CC -> . d [c/d/$]
 CC -> . c CC [c/d/$]
 CC -> c . CC [$/d/c]
GOTO(CC) = 5
GOTO(d) = 3
GOTO(c) = 4

Itemset 5
 CC -> c CC . [c/d/$]

Itemset 6
 S -> CC CC . [$]

=== ACTION TABLE ===
STATE TERMINAL      ACTION
0     c             shift to state 4
      d             shift to state 3
1     <any>         accept
2     c             shift to state 4
      d             shift to state 3
3     <any>         reduce by #2: CC -> [1 symbols] (lambda (!$1) (quote d))
4     c             shift to state 4
      d             shift to state 3
5     <any>         reduce by #3: CC -> [2 symbols] (lambda (!$1 !$2) (list (
quote c) !$2))
6     <any>         reduce by #1: S -> [2 symbols] 

=== GOTO TABLE ===
NONTERMINAL         SRC     DEST
S                   <any>   1
CC                  4       5
                    2       6
                    <any>   2


(((nil 6 . d) (nil 5 . c) (nil 0 . !:eof) (nil 1 . !:symbol) (nil 2 . !:string)
(nil 3 . !:number) (nil 4 . !:list)) [(((5 . 4) (6 . 3))) (nil . 0) (((5 . 4) (6
. 3))) (nil . -2) (((5 . 4) (6 . 3))) (nil . -3) (nil . -1)] ([nil nil
action0001 action0002] #V8(1 2 1 2) #V16(-1 0 1 1 7730 0 0 0)) [(nil . 1) (((4 .
5) (2 . 6)) . 2) nil] ((-1 . !S!') (1 . cc) (0 . s)) ((6 . d) (5 . c) (4 .
!:list) (3 . !:number) (2 . !:string) (1 . !:symbol) (0 . !:eof)))


symbolic procedure pparse g;
  begin
    scalar r;
    r := yyparse g;
    terpri();
    princ "= ";
    print r
  end;


pparse


pparse g$



c Shift token 5 onto stack, and shift to state 4
c Shift token 5 onto stack, and shift to state 4
c Shift token 5 onto stack, and shift to state 4
d Shift token 6 onto stack, and shift to state 3
On lookahead -1, reduce 1 symbols to nonterminal CC, and goto state 5
On lookahead -1, reduce 2 symbols to nonterminal CC, and goto state 5
On lookahead -1, reduce 2 symbols to nonterminal CC, and goto state 5
On lookahead -1, reduce 2 symbols to nonterminal CC, and goto state 2
c Shift token 5 onto stack, and shift to state 4
d Shift token 6 onto stack, and shift to state 3
On lookahead -1, reduce 1 symbols to nonterminal CC, and goto state 5
On lookahead -1, reduce 2 symbols to nonterminal CC, and goto state 6
On lookahead -1, reduce 2 symbols to nonterminal S, and goto state 1
Seems to have finished... 
= ((c (c (c d))) (c d))
;


nil


pparse g$



d Shift token 6 onto stack, and shift to state 3
On lookahead -1, reduce 1 symbols to nonterminal CC, and goto state 2
d Shift token 6 onto stack, and shift to state 3
On lookahead -1, reduce 1 symbols to nonterminal CC, and goto state 6
On lookahead -1, reduce 2 symbols to nonterminal S, and goto state 1
Seems to have finished... 
= (d d)
;


nil



% Now switch off the tracing. It is useful while debugging this
% package but is typically rather over the top for normal use.

off tracelex, lalr_verbose;


nil


% Example 4.46 from the Red Dragon (4.61 in Aho, Lam, Sethi and Ullman,
% "Compilers: principles, techniques and tools", second edition 2007).
%
% This is used there as an example of a grammar that is not SLR(1) but
% that can be handled by LALR .

% The semantic actions here contain print statements that will
% print some sort of trace as the parsing progresses.

symbolic procedure neatprintc x;
 << if not zerop posn() then terpri();
    printc x >>;


neatprintc


g4_46 := '((s   ((l "=" r)   (neatprintc "## S => L = R")
                             (list 'equal !$1 !$3))
                ((r)         (neatprintc "## S => R")
                             !$1))
           (l   (("*" r)     (neatprintc "## L => * R")
                             (list 'star !$2))
                ((!:symbol)  (neatprintc "## L => symbol")
                             !$1))
           (r   ((l)         (neatprintc "## R => L")
                             !$1)));


((s ((l "=" r) (neatprintc "## S => L = R") (list (quote equal) !$1 !$3)) ((r) (
neatprintc "## S => R") !$1)) (l (("*" r) (neatprintc "## L => * R") (list (
quote star) !$2)) ((!:symbol) (neatprintc "## L => symbol") !$1)) (r ((l) (
neatprintc "## R => L") !$1)))


g := lalr_create_parser(nil, g4_46);


(((nil 6 . !*) (nil 5 . !=) (nil 0 . !:eof) (nil 1 . !:symbol) (nil 2 . !:string
) (nil 3 . !:number) (nil 4 . !:list)) [(((1 . 4) (6 . 5))) (nil . 0) (((5 . 8))
. -5) (nil . -1) (nil . -3) (((1 . 4) (6 . 5))) (nil . -5) (nil . -4) (((1 . 4)
(6 . 5))) (nil . -2)] ([nil action0003 action0004 action0005 action0006
action0007] #V8(1 1 3 1 2 1 0 0) #V16(-1 0 0 1 1 2 0 0 8754 0)) [(nil . 1) (((0
. 2)) . 6) (((5 . 7) (8 . 9)) . 3) nil] ((-1 . !S!') (1 . cc) (0 . s)) ((6 . !*)
(5 . !=) (4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol) (0 . !:eof)))


pparse g$



leftsym 
## L => symbol
= rightsym 
## L => symbol
## R => L
## S => L = R

= (equal leftsym rightsym)
;


nil



pparse g$



****abc 
## L => symbol
## R => L
## L => * R
## R => L
## L => * R
## R => L
## L => * R
## R => L
## L => * R
= *def 
## L => symbol
## R => L
## L => * R
## R => L
## S => L = R

= (equal (star (star (star (star abc)))) (star def))
;


nil


% This next example is expected to be reasonably representative of
% small grammars. It needs precedence rules to disambiguate the
% grammar, and illustrates both left and right associativity, and
% cases where two operators have the same precedence.

gtest := '((s  ((p))
               ((s "^" s) (list 'expt !$1 !$3))
               ((s "**" s) (list 'expt !$1 !$3))
               ((s "*" s) (list 'times !$1 !$3))
               ((s "/" s) (list 'quotient !$1 !$3))
               ((s "+" s) (list 'plus !$1 !$3))
               ((s "-" s) (list 'difference !$1 !$3))
               ((s "=" s) (list 'equal !$1 !$3))
               (("-" s) (list 'minus !$2))
               (("+" s) !$2))

           (p  (("(" s ")") !$2)
               ((!:symbol))
               ((!:string))
               ((!:number))));


((s ((p)) ((s "^" s) (list (quote expt) !$1 !$3)) ((s "**" s) (list (quote expt)
!$1 !$3)) ((s "*" s) (list (quote times) !$1 !$3)) ((s "/" s) (list (quote
quotient) !$1 !$3)) ((s "+" s) (list (quote plus) !$1 !$3)) ((s "-" s) (list (
quote difference) !$1 !$3)) ((s "=" s) (list (quote equal) !$1 !$3)) (("-" s) (
list (quote minus) !$2)) (("+" s) !$2)) (p (("(" s ")") !$2) ((!:symbol)) ((
!:string)) ((!:number))))


% "^" and "**" both have the same high precedence and are right
% associative. Next come "*" and "/" which are left associative,
% and after that "+" and "-". Finally "=" has lowest precedence and
% must not associate with itself, so (a=b=c) should be a syntax error.

p := '(!:right ("^" "**") !:left ("*" "/") ("+" "-") !:none "=");


(!:right ("^" "**") !:left ("*" "/") ("+" "-") !:none "=")


g := lalr_create_parser(p, gtest);


(((nil 13 . !)) (nil 12 . !() (nil 11 . !=) (nil 10 . !-) (nil 9 . !+) (nil 8 .
!/) (((!* . !*!*)) 7 . !*) (nil 6 . !*!*) (nil 5 . !^) (nil 0 . !:eof) (nil 1 .
!:symbol) (nil 2 . !:string) (nil 3 . !:number) (nil 4 . !:list)) [(((1 . 5) (2
. 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))) (((5 . 16) (6 . 15) (7 . 14) (8 . 13) (
9 . 12) (10 . 11) (11 . 10)) . 0) (nil . -9) (nil . -10) (nil . -10) (nil . -10)
(((1 . 5) (2 . 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))) (((1 . 5) (2 . 4) (3 . 3)
(9 . 8) (10 . 7) (12 . 6))) (((1 . 5) (2 . 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))
) (((5 . 16) (6 . 15) (7 . 14) (8 . 13)) . -1) (((1 . 5) (2 . 4) (3 . 3) (9 . 8)
(10 . 7) (12 . 6))) (((1 . 5) (2 . 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))) (((1 .
5) (2 . 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))) (((1 . 5) (2 . 4) (3 . 3) (9 . 8)
(10 . 7) (12 . 6))) (((1 . 5) (2 . 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))) (((1 .
5) (2 . 4) (3 . 3) (9 . 8) (10 . 7) (12 . 6))) (((1 . 5) (2 . 4) (3 . 3) (9 . 8)
(10 . 7) (12 . 6))) (((5 . 16) (6 . 15)) . -8) (((5 . 16) (6 . 15)) . -8) (((5 .
16) (6 . 15)) . -7) (((5 . 16) (6 . 15)) . -6) (((5 . 16) (6 . 15) (7 . 14) (8 .
13)) . -5) (((5 . 16) (6 . 15) (7 . 14) (8 . 13)) . -4) (((5 . 16) (6 . 15) (7 .
14) (8 . 13) (9 . 12) (10 . 11)) . -3) (((5 . 16) (6 . 15) (7 . 14) (8 . 13)) .
-2) (((5 . 16) (6 . 15) (7 . 14) (8 . 13) (9 . 12) (10 . 11) (11 . 10) (13 . 26)
)) (nil . -11)] ([nil action0008 action0009 action0010 action0011 action0012
action0013 action0014 action0015 nil nil action0016] #V8(1 2 2 3 3 3 3 3 3 1 1 3
) #V16(-1 0 0 0 0 0 0 0 0 0 1 1 11826 0 0 0)) [(((8 . 9) (16 . 17) (15 . 18) (14
. 19) (13 . 20) (12 . 21) (11 . 22) (10 . 23) (7 . 24) (6 . 25)) . 1) (nil . 2)
nil] ((-1 . !S!') (1 . cc) (0 . s)) ((13 . !)) (12 . !() (11 . !=) (10 . !-) (9
. !+) (8 . !/) (7 . !*) (6 . !*!*) (5 . !^) (4 . !:list) (3 . !:number) (2 .
!:string) (1 . !:symbol) (0 . !:eof)))


pparse g$


a^b^c;
= (expt a (expt b c))


pparse g$


a*b+c*d;
= (plus (times a b) (times c d))


pparse g$


a * (b/c + d/e/f) ^ 2 ^ g - "str" ;
= (difference (times a (expt (plus (quotient b c) (quotient (quotient d e) f)) (
expt !:string g))) "str")


% Demonstrate various of the short-hand notations...

g := lalr_create_parser(nil, '(
 (s
% (opt ...) means that the included material is optional.
          (("begin" (opt "and" "also") "end")))));


(((nil 8 . also) (nil 7 . and) (nil 6 . end) (nil 5 . begin) (nil 0 . !:eof) (
nil 1 . !:symbol) (nil 2 . !:string) (nil 3 . !:number) (nil 4 . !:list)) [(((5
. 2))) (nil . 0) (((7 . 4)) . -3) (((6 . 6))) (((8 . 5))) (nil . -2) (nil . -1)]
([nil nil nil nil] #V8(1 3 2 0) #V16(-1 0 1 1 7730 0 0 0)) [(nil . 1) (nil . 3)
nil] ((-1 . !S!') (1 . cc) (0 . s)) ((8 . also) (7 . and) (6 . end) (5 . begin)
(4 . !:list) (3 . !:number) (2 . !:string) (1 . !:symbol) (0 . !:eof)))


pparse g$


begin end

= (begin nil end)
;


nil
;


nil


pparse g$


begin and also end

= (begin (and also) end)
;


nil
;


nil


g := lalr_create_parser(nil, '(
 (s
% (star ...) is for zero or mor instances of something.
          (((star "a") "end") !$1))));


(((nil 6 . a) (nil 5 . end) (nil 0 . !:eof) (nil 1 . !:symbol) (nil 2 . !:string
) (nil 3 . !:number) (nil 4 . !:list)) [(((6 . 3)) . -3) (nil . 0) (((5 . 5))) (
((6 . 3)) . -3) (nil . -2) (nil . -1)] ([nil action0017 action0018 nil] #V8(1 2
2 0) #V16(-1 0 1 1 7730 0 0 0)) [(nil . 1) (((3 . 4)) . 2) nil] ((-1 . !S!') (1
. cc) (0 . s)) ((6 . a) (5 . end) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof)))


pparse g$


end

= nil
;


nil
;


nil


pparse g$


a a a a a a end

= (a a a a a a)
;


nil
;


nil


g := lalr_create_parser(nil, '(
 (s
% (plus ...) is for one or more repetitions of an item
          (((plus "a") "end") !$1))));


(((nil 6 . a) (nil 5 . end) (nil 0 . !:eof) (nil 1 . !:symbol) (nil 2 . !:string
) (nil 3 . !:number) (nil 4 . !:list)) [(((6 . 3))) (nil . 0) (((5 . 5))) (((6 .
3)) . -3) (nil . -2) (nil . -1)] ([nil action0019 action0020 action0021] #V8(1 2
2 1) #V16(-1 0 1 1 7730 0 0 0)) [(nil . 1) (((3 . 4)) . 2) nil] ((-1 . !S!') (1
. cc) (0 . s)) ((6 . a) (5 . end) (4 . !:list) (3 . !:number) (2 . !:string) (1
. !:symbol) (0 . !:eof)))


pparse g$


a end

= (a)
;


nil
;


nil


pparse g$


a a a a a a end

= (a a a a a a)
;


nil
;


nil


g := lalr_create_parser(nil, '(
 (s
% (list delimiter item-description) is a sequence of zero
% or more items, and if there are several that are separated by the
% indicated delimiter. 
          (((list ";" !:symbol) "eof") !$1))));


(((nil 6 . !;) (nil 5 . eof) (nil 0 . !:eof) (nil 1 . !:symbol) (nil 2 .
!:string) (nil 3 . !:number) (nil 4 . !:list)) [(((1 . 3)) . -3) (nil . 0) (((5
. 8))) (((6 . 5)) . -5) (nil . -2) (((1 . 6))) (((6 . 5)) . -5) (nil . -4) (nil
. -1)] ([nil action0022 action0023 nil action0024 nil] #V8(1 2 2 0 3 0 0 0)
#V16(-1 0 1 1 2 2 0 0 8754 0)) [(nil . 1) (nil . 2) (((6 . 7)) . 4) nil] ((-1 .
!S!') (1 . cc) (0 . s)) ((6 . !;) (5 . eof) (4 . !:list) (3 . !:number) (2 .
!:string) (1 . !:symbol) (0 . !:eof)))


pparse g$



several ; words ; here eof

= (several words here)
;


nil
;


nil


g := lalr_create_parser(nil, '(
 (s
% (listplus delimiter item-description) is as (list ...) however it
% requires at least one item.
          (((listplus ";" !:symbol) "eof") !$1))));


(((nil 6 . !;) (nil 5 . eof) (nil 0 . !:eof) (nil 1 . !:symbol) (nil 2 .
!:string) (nil 3 . !:number) (nil 4 . !:list)) [(((1 . 3))) (nil . 0) (((5 . 8))
) (((6 . 5)) . -4) (nil . -2) (((1 . 6))) (((6 . 5)) . -4) (nil . -3) (nil . -1)
] ([nil action0025 action0026 action0027 nil] #V8(1 2 2 3 0 0 0 0) #V16(-1 0 1 2
2 0 0 0 8242)) [(nil . 1) (nil . 2) (((6 . 7)) . 4) nil] ((-1 . !S!') (1 . cc) (
0 . s)) ((6 . !;) (5 . eof) (4 . !:list) (3 . !:number) (2 . !:string) (1 .
!:symbol) (0 . !:eof)))


pparse g$



several ; words ; here eof

= (several words here)
;


nil
;


nil


g := lalr_create_parser(nil, '(
 (s
% (or x y z) may be a more compact way of writing what could
% otherwise by given as multiple productions, so for instance
% (or "+" "-" "*" "/") would match one of the listed operators.
          (((star (or "a" "b")) "end") !$1))));


(((nil 7 . b) (nil 6 . a) (nil 5 . end) (nil 0 . !:eof) (nil 1 . !:symbol) (nil
2 . !:string) (nil 3 . !:number) (nil 4 . !:list)) [(((6 . 6) (7 . 5)) . -3) (
nil . 0) (((5 . 8))) (((6 . 6) (7 . 5)) . -3) (nil . -4) (nil . -5) (nil . -5) (
nil . -2) (nil . -1)] ([nil action0028 action0029 nil nil nil] #V8(1 2 2 0 1 1 0
0) #V16(-1 0 1 1 2 3 0 0 8754 0)) [(nil . 1) (((3 . 7)) . 2) (nil . 3) (nil . 4)
nil] ((-1 . !S!') (1 . cc) (0 . s)) ((7 . b) (6 . a) (5 . end) (4 . !:list) (3 .
!:number) (2 . !:string) (1 . !:symbol) (0 . !:eof)))


pparse g$


end

= nil
;


nil
;


nil


pparse g$


a b b a end

= (a b b a)
;


nil
;


nil


% The next example shows all the above put together to parse what is
% in effect a small programming language. Although it is not yet a large
% grammar it illustrates painfull clearly how poor performange of the
% parser generator can be if ut used what Aho, Sethi and Ullman describe as
% the "Easy but space-consuming LALR table construction" method.

p := '(!:left ("*" "/")
              ("+" "-")
       !:none ("<" "<=" "==" "neq" ">=" ">")
       !:right ":=" "="
       !:left ("then" "else" "return"));


(!:left ("*" "/") ("+" "-") !:none ("<" "<=" "==" "neq" ">=" ">") !:right ":="
"=" !:left ("then" "else" "return"))


mini_language := '(
 (program
          (((listplus ";" expression) "eof") !$1))

 (expression
          ((funcall))
          ((expression "*" expression) (list 'times !$1 !$3))
          ((expression "/" expression) (list 'quotient !$1 !$3))
          ((expression "+" expression) (list 'plus !$1 !$3))
          ((expression "-" expression) (list 'difference !$1 !$3))
          ((expression "<" expression) (list 'lessp !$1 !$3))
          ((expression "<=" expression) (list 'lesseq !$1 !$3))
          ((expression "==" expression) (list 'equals !$1 !$3))
          ((expression "neq" expression) (list 'neq !$1 !$3))
          ((expression "=>" expression) (list 'geq !$1 !$3))
          ((expression ">" expression) (list 'greaterp !$1 !$3))
          ((expression ":=" expression) (list 'setq !$1 !$3))
          (("fun" funcall "=" expression) (list 'fun !$2 !$4))
          (("if" sequence "then" expression)
             (list 'cond, list(!$2, !$4)))
          (("if" sequence "then" sequence "else" expression)
             (list 'cond, list(!$2, !$4), list(t, !$6)))
          (("go" (opt "to") !:symbol) (list 'go !$3))
          (("goto" !:symbol) (list 'go !$2))
          (("return" expression)))

(funcall
          ((closedexpression))
          ((funcall closedexpression)))

(closedexpression
          ((!:symbol))
          ((!:number))
          (((plus !:string))) % Several strings in a row just concatenate
          (("let" sequence "in" sequence "end") (list 'letstat !$2 !$4))
          (("(" exprlist ")") (cons 'paren !$2))
          (("(" sequence ")") (cons 'paren !$2))
          (("[" exprlist "]") (cons 'bracket !$2)))

(exprlist (((list "," expression))))

(sequence
          (((list ";" expression)))))$



% The grammar shown here used to fail for lack of space. It should now
% behave.
% One issue it reveals at right now is that the processing here does not
% keep the types of terminal symbols under control carefully enough, so the
% numeric values 22 and 33 in the sample text get transliterated back into
% terminal symbols that happen to have ended up allocated numeric codes
% 22 and 33. This NEEDS fixing, but is not really an issue for the
% code that manufactures parsing tables.
%
%                                                       ACN   May 2016

on tracelex, lalr_verbose;


nil


g := lalr_create_parser(p, mini_language);

Token 'eof' allocated code 5
Token '!;' allocated code 6
Token '!*' allocated code 7
Token '!/' allocated code 8
Token '!+' allocated code 9
Token '!-' allocated code 10
Token '!<' allocated code 11
dipthong data '!<' plus '!=' => '!<!='
Token '!=' allocated code 14
dipthong data '!=' plus '!=' => '!=!='
Token 'neq' allocated code 15
dipthong data '!=' plus '!>' => '!=!>'
Token '!>' allocated code 17
Token '!:' allocated code 19
dipthong data '!:' plus '!=' => '!:!='
Token 'fun' allocated code 20
Token 'if' allocated code 21
Token 'then' allocated code 22
Token 'else' allocated code 23
Token 'go' allocated code 24
Token 'goto' allocated code 25
Token 'return' allocated code 26
Token 'to' allocated code 27
Token 'let' allocated code 28
Token 'in' allocated code 29
Token 'end' allocated code 30
Token '!(' allocated code 31
Token '!)' allocated code 32
Token '![' allocated code 33
Token '!]' allocated code 34
Token '!,' allocated code 35
=== Terminal symbols ===
   , [35]
   :string [2]
   ] [34]
   [ [33]
   ) [32]
   ( [31]
   end [30]
   in [29]
   let [28]
   :number [3]
   to [27]
   return [26] (precedence 5, left associativity)
   goto [25]
   :symbol [1]
   go [24]
   else [23] (precedence 5, left associativity)
   then [22] (precedence 5, left associativity)
   if [21]
   = [14] (precedence 4, right associativity)
   fun [20]
   := [18] (precedence 3, right associativity)
   > [17] (precedence 2, none associativity)
   => [16]
   neq [15] (precedence 2, none associativity)
   == [13] (precedence 2, none associativity)
   <= [12] (precedence 2, none associativity)
   < [11] (precedence 2, none associativity)
   - [10] (precedence 1, left associativity)
   + [9] (precedence 1, left associativity)
   / [8] (precedence 0, left associativity)
   * [7] (precedence 0, left associativity)
   ; [6]
   eof [5]

"=== Nonterminal symbols ==="
[-1] S'             : PROGRAM                   { nil }

[0] PROGRAM         : LALR_INTERNAL_15 eof      { (!$1) }

[1] LALR_INTERNAL_15: EXPRESSION LALR_INTERNAL_17 
                                                { ((cons !$1 !$2)) }

[2] LALR_INTERNAL_17: ; EXPRESSION LALR_INTERNAL_17 
                                                { ((cons !$2 !$3)) }
                    | <empty>                   { nil }

[3] EXPRESSION      : return EXPRESSION         { nil }
                    | goto :symbol              { ((list (quote go) !$2)) }
                    | go LALR_INTERNAL_18 :symbol 
                                                { ((list (quote go) !$3)) }
                    | if SEQUENCE then SEQUENCE else EXPRESSION 
                                                { ((list (quote cond) !, list (
!$2 !, !$4) !, list (t !, !$6))) }
                    | if SEQUENCE then EXPRESSION 
                                                { ((list (quote cond) !, list (
!$2 !, !$4))) }
                    | fun FUNCALL = EXPRESSION  { ((list (quote fun) !$2 !$4)) }
                    | EXPRESSION := EXPRESSION  { ((list (quote setq) !$1 !$3))
 }
                    | EXPRESSION > EXPRESSION   { ((list (quote greaterp) !$1
!$3)) }
                    | EXPRESSION => EXPRESSION  { ((list (quote geq) !$1 !$3)) }
                    | EXPRESSION neq EXPRESSION { ((list (quote neq) !$1 !$3)) }
                    | EXPRESSION == EXPRESSION  { ((list (quote equals) !$1 !$3)
) }
                    | EXPRESSION <= EXPRESSION  { ((list (quote lesseq) !$1 !$3)
) }
                    | EXPRESSION < EXPRESSION   { ((list (quote lessp) !$1 !$3))
 }
                    | EXPRESSION - EXPRESSION   { ((list (quote difference) !$1
!$3)) }
                    | EXPRESSION + EXPRESSION   { ((list (quote plus) !$1 !$3))
 }
                    | EXPRESSION / EXPRESSION   { ((list (quote quotient) !$1
!$3)) }
                    | EXPRESSION * EXPRESSION   { ((list (quote times) !$1 !$3))
 }
                    | FUNCALL                   { nil }

[4] LALR_INTERNAL_18: to                        { nil }
                    | <empty>                   { nil }

[5] FUNCALL         : FUNCALL CLOSEDEXPRESSION  { nil }
                    | CLOSEDEXPRESSION          { nil }

[6] CLOSEDEXPRESSION: [ EXPRLIST ]              { ((cons (quote bracket) !$2)) }
                    | ( SEQUENCE )              { ((cons (quote paren) !$2)) }
                    | ( EXPRLIST )              { ((cons (quote paren) !$2)) }
                    | let SEQUENCE in SEQUENCE end 
                                                { ((list (quote letstat) !$2 !$4
)) }
                    | LALR_INTERNAL_19          { nil }
                    | :number                   { nil }
                    | :symbol                   { nil }

[7] LALR_INTERNAL_19: :string LALR_INTERNAL_19  { ((cons !$1 !$2)) }
                    | :string                   { ((list !$1)) }

[8] EXPRLIST        : LALR_INTERNAL_21          { nil }

[9] LALR_INTERNAL_21: EXPRESSION LALR_INTERNAL_23 
                                                { ((cons !$1 !$2)) }
                    | <empty>                   { nil }

[10] LALR_INTERNAL_23: , EXPRESSION LALR_INTERNAL_23 
                                                { ((cons !$2 !$3)) }
                    | <empty>                   { nil }

[11] SEQUENCE       : LALR_INTERNAL_24          { nil }

[12] LALR_INTERNAL_24: EXPRESSION LALR_INTERNAL_26 
                                                { ((cons !$1 !$2)) }
                    | <empty>                   { nil }

[13] LALR_INTERNAL_26: ; EXPRESSION LALR_INTERNAL_26 
                                                { ((cons !$2 !$3)) }
                    | <empty>                   { nil }


=== FIRST sets for each nonterminal ===
S':                 :string [ ( let :number :symbol return goto go if fun 
PROGRAM:            :string :symbol :number let ( [ fun if go goto return 
LALR_INTERNAL_15:   :string [ ( let :number :symbol return goto go if fun 
LALR_INTERNAL_17:   NIL ; 
EXPRESSION:         :string :symbol :number let ( [ fun if go goto return 
LALR_INTERNAL_18:   NIL to 
FUNCALL:            :string [ ( let :number :symbol 
CLOSEDEXPRESSION:   :string :symbol :number let ( [ 
LALR_INTERNAL_19:   :string 
EXPRLIST:           :string :symbol :number let ( [ NIL fun if go goto return 
LALR_INTERNAL_21:   :string [ ( let :number :symbol NIL return goto go if fun 
LALR_INTERNAL_23:   NIL , 
SEQUENCE:           :string :symbol :number let ( [ NIL fun if go goto return 
LALR_INTERNAL_24:   :string [ ( let :number :symbol NIL return goto go if fun 
LALR_INTERNAL_26:   NIL ; 

=== LALR ITEMSET COLLECTION ===

Itemset 0
 S' -> . PROGRAM [$]
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [:=/>/=>/neq/==/<=/</-/+///*/eof/:string
/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:=/>/=>/neq/==/<=/</-/+///*
/eof/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:symbol/
:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:symbol/
:number/let/(/[/;]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/;/eof]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:num
ber/let/(/[/;/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:sym
bol/:number/let/(/[/;/eof]
 LALR_INTERNAL_15 -> . EXPRESSION LALR_INTERNAL_17 [eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [:=/>/=>/neq/==/<=/</-/+///*/eof
/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_19 -> . :string [:=/>/=>/neq/==/<=/</-/+///*/eof/[/(/let/:number/
:symbol/:string/;]
 PROGRAM -> . LALR_INTERNAL_15 eof [$]
GOTO(PROGRAM) = 1
GOTO(LALR_INTERNAL_15) = 2
GOTO(EXPRESSION) = 3
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 1
 S' -> PROGRAM . [$]

Itemset 2
 PROGRAM -> LALR_INTERNAL_15 . eof [$]
GOTO(eof) = 83

Itemset 3
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_15 -> EXPRESSION . LALR_INTERNAL_17 [eof]
 LALR_INTERNAL_17 -> . ; EXPRESSION LALR_INTERNAL_17 [eof]
 LALR_INTERNAL_17 -> . [eof]
GOTO(LALR_INTERNAL_17) = 79
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32
GOTO(;) = 80

Itemset 4
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [end/else/then/in/)/,/]/:=/>/=>/neq/==/<
=/</-/+///*/:string/:symbol/:number/let/(/[/;/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</
-/+///*/:string/:symbol/:number/let/(/[/;/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</
-/+///*/:string/:symbol/:number/let/(/[/;/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</
-/+///*/:string/:symbol/:number/let/(/[/;/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [end/else/then/in/)/,/]/:=/>
/=>/neq/==/<=/</-/+///*/:string/:symbol/:number/let/(/[/;/eof]
 CLOSEDEXPRESSION -> . :number [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+//
/*/:string/:symbol/:number/let/(/[/;/eof]
 CLOSEDEXPRESSION -> . :symbol [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+//
/*/:string/:symbol/:number/let/(/[/;/eof]
 EXPRESSION -> FUNCALL . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/*///+/-/</<=/==/
neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*///+/-/</<=/==/neq/=>/>/:=/in/;
/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/
neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+
/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*
///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/
:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=
>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/n
eq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/;/*///
+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/neq/=>/>/:=/,/*///+/-/</<=/==/neq/
=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
 FUNCALL -> FUNCALL . CLOSEDEXPRESSION [eof/;/[/(/let/:number/:symbol/:string/*/
//+/-/</<=/==/neq/=>/>/:=/]/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/ne
q/=>/>/:=/)/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/)/;/[/
(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/in/;/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/then/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/ne
q/=>/>/:=/then/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(
/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol
/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<
=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(
/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol
/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<
=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(
/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol
/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<
=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(
/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/else/;/[/(/let/:number/
:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///
+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>
/>/:=/end/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/,/[/(/le
t/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/
:string/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [eof/;/[/(/let/:number/:symbol/:
string/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/else/end]
 LALR_INTERNAL_19 -> . :string [eof/;/[/(/let/:number/:symbol/:string/*///+/-/</
<=/==/neq/=>/>/:=/]/,/)/in/then/else/end]
GOTO(CLOSEDEXPRESSION) = 19
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(:symbol) = 14

Itemset 5
 FUNCALL -> CLOSEDEXPRESSION . [eof/;/[/(/let/:number/:symbol/:string/*///+/-/</
<=/==/neq/=>/>/:=/]/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:
=/)/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/)/;/[/(/let/:n
umber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/in/;/[/(/let/:number/:symbol/:
string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/
==/neq/=>/>/:=/then/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:
=/then/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/=/[/(/let/:
number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/else/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:n
umber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:str
ing/*///+/-/</<=/==/neq/=>/>/:=/end/;/[/(/let/:number/:symbol/:string/*///+/-/</
<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/
;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]

Itemset 6
 CLOSEDEXPRESSION -> LALR_INTERNAL_19 . [;/[/(/let/:number/:symbol/:string/eof/*
///+/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+/-/</<=/==/n
eq/=>/>/:=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(
/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:sy
mbol/:string/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///
+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/n
eq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:=/=/
[/(/let/:number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/
neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/
:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:str
ing/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/
neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/
:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:str
ing/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/
neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/
:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:str
ing/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/
neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/neq/=>/>/:=/[
/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:sy
mbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/end/*
///+/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq
/=>/>/:=/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]

Itemset 7
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [end/else/=/then/in/)/]/,/:=/>/=
>/neq/==/<=/</-/+///*/eof/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_19 -> . :string [end/else/=/then/in/)/]/,/:=/>/=>/neq/==/<=/</-/+
///*/eof/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_19 -> :string . LALR_INTERNAL_19 [;/:string/:symbol/:number/let/(
/[/eof/*///+/-/</<=/==/neq/=>/>/:=/,/:string/:symbol/:number/let/(/[/]/*///+/-/<
/<=/==/neq/=>/>/:=/,/:string/:symbol/:number/let/(/[/)/*///+/-/</<=/==/neq/=>/>/
:=/;/:string/:symbol/:number/let/(/[/)/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:sy
mbol/:number/let/(/[/in/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/
(/[/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/(/[/then/*///+/-/<
/<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/(/[/then/*///+/-/</<=/==/neq/=>
/>/:=/=/:string/:symbol/:number/let/(/[/:string/:symbol/:number/let/(/[/*///+/-/
</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/
:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:num
ber/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/
</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/
:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:num
ber/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/
</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/
:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:num
ber/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/
</<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/(/[/else/*///+/-/</<=/==/neq/=
>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:sy
mbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/(
/[/end/*///+/-/</<=/==/neq/=>/>/:=/,/:string/:symbol/:number/let/(/[/*///+/-/</<
=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_19 -> :string . [;/:string/:symbol/:number/let/(/[/eof/*///+/-/</
<=/==/neq/=>/>/:=/,/:string/:symbol/:number/let/(/[/]/*///+/-/</<=/==/neq/=>/>/:
=/,/:string/:symbol/:number/let/(/[/)/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:sym
bol/:number/let/(/[/)/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/
(/[/in/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/
==/neq/=>/>/:=/;/:string/:symbol/:number/let/(/[/then/*///+/-/</<=/==/neq/=>/>/:
=/;/:string/:symbol/:number/let/(/[/then/*///+/-/</<=/==/neq/=>/>/:=/=/:string/:
symbol/:number/let/(/[/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/
:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:
number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+
/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/
:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:
number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+
/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/
:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:
number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+
/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/
:=/;/:string/:symbol/:number/let/(/[/else/*///+/-/</<=/==/neq/=>/>/:=/:string/:s
ymbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/
(/[/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/(/[/end/*///+/-/</
<=/==/neq/=>/>/:=/,/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/
;/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=]
GOTO(LALR_INTERNAL_19) = 78
GOTO(:string) = 7

Itemset 8
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [:=/>/=>/neq/==/<=/</-/+///*/]/:string/:
symbol/:number/let/(/[/,]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:=/>/=>/neq/==/<=/</-/+///*/]/:string/:symb
ol/:number/let/(/[/,]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:=/>/=>/neq/==/<=/</-/+///*/]/:string/:symb
ol/:number/let/(/[/,]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:=/>/=>/neq/==/<=/</-/+///*/]/:string/:symb
ol/:number/let/(/[/,]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:=/>/=>/neq/==/<=/</-/+///*
/]/:string/:symbol/:number/let/(/[/,]
 CLOSEDEXPRESSION -> . :number [:=/>/=>/neq/==/<=/</-/+///*/]/:string/:symbol/:n
umber/let/(/[/,]
 CLOSEDEXPRESSION -> . :symbol [:=/>/=>/neq/==/<=/</-/+///*/]/:string/:symbol/:n
umber/let/(/[/,]
 CLOSEDEXPRESSION -> [ . EXPRLIST ] [;/[/(/let/:number/:symbol/:string/eof/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+/-/</<=/==/neq/=
>/>/:=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let
/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol
/:string/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/
</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=
>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:=/=/[/(/
let/:number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/neq/=>/>/:=/[/(/l
et/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol
/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/end/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/
>/:=/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRLIST -> . LALR_INTERNAL_21 []]
 FUNCALL -> . CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:num
ber/let/(/[/,/]]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:sym
bol/:number/let/(/[/,/]]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [:=/>/=>/neq/==/<=/</-/+///*/]/[
/(/let/:number/:symbol/:string/,]
 LALR_INTERNAL_19 -> . :string [:=/>/=>/neq/==/<=/</-/+///*/]/[/(/let/:number/:s
ymbol/:string/,]
 LALR_INTERNAL_21 -> . EXPRESSION LALR_INTERNAL_23 []]
 LALR_INTERNAL_21 -> . []]
GOTO(EXPRESSION) = 75
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(EXPRLIST) = 76
GOTO(LALR_INTERNAL_21) = 67
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 9
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [,/:=/>/=>/neq/==/<=/</-/+///*/)/:string
/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [,/:=/>/=>/neq/==/<=/</-/+///*/)/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [,/:=/>/=>/neq/==/<=/</-/+///*/)/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [,/:=/>/=>/neq/==/<=/</-/+///*/)/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [,/:=/>/=>/neq/==/<=/</-/+//
/*/)/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [,/:=/>/=>/neq/==/<=/</-/+///*/)/:string/:symbol/
:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [,/:=/>/=>/neq/==/<=/</-/+///*/)/:string/:symbol/
:number/let/(/[/;]
 CLOSEDEXPRESSION -> ( . EXPRLIST ) [;/[/(/let/:number/:symbol/:string/eof/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+/-/</<=/==/neq/=
>/>/:=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let
/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol
/:string/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/
</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=
>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:=/=/[/(/
let/:number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/neq/=>/>/:=/[/(/l
et/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol
/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/end/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/
>/:=/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]
 CLOSEDEXPRESSION -> ( . SEQUENCE ) [;/[/(/let/:number/:symbol/:string/eof/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+/-/</<=/==/neq/=
>/>/:=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let
/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol
/:string/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/
</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=
>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:=/=/[/(/
let/:number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/neq/=>/>/:=/[/(/l
et/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol
/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/end/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/
>/:=/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> . EXPRESSION := EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION > EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION => EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION == EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION < EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION - EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION + EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION / EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION * EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . FUNCALL [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . return EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . goto :symbol [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [,/:=/>/=>/neq/==/<=/
</-/+///*/;/)]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRLIST -> . LALR_INTERNAL_21 [)]
 FUNCALL -> . CLOSEDEXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:n
umber/let/(/[/;/)]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/:string/:s
ymbol/:number/let/(/[/;/)]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [,/:=/>/=>/neq/==/<=/</-/+///*/)
/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_19 -> . :string [,/:=/>/=>/neq/==/<=/</-/+///*/)/[/(/let/:number/
:symbol/:string/;]
 LALR_INTERNAL_21 -> . EXPRESSION LALR_INTERNAL_23 [)]
 LALR_INTERNAL_21 -> . [)]
 LALR_INTERNAL_24 -> . EXPRESSION LALR_INTERNAL_26 [)]
 LALR_INTERNAL_24 -> . [)]
 SEQUENCE -> . LALR_INTERNAL_24 [)]
GOTO(EXPRESSION) = 65
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(EXPRLIST) = 66
GOTO(LALR_INTERNAL_21) = 67
GOTO(SEQUENCE) = 68
GOTO(LALR_INTERNAL_24) = 46
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 10
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [:=/>/=>/neq/==/<=/</-/+///*/in/:string/
:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:=/>/=>/neq/==/<=/</-/+///*/in/:string/:sym
bol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:=/>/=>/neq/==/<=/</-/+///*/in/:string/:sym
bol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:=/>/=>/neq/==/<=/</-/+///*/in/:string/:sym
bol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:=/>/=>/neq/==/<=/</-/+///*
/in/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [:=/>/=>/neq/==/<=/</-/+///*/in/:string/:symbol/:
number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [:=/>/=>/neq/==/<=/</-/+///*/in/:string/:symbol/:
number/let/(/[/;]
 CLOSEDEXPRESSION -> let . SEQUENCE in SEQUENCE end [;/[/(/let/:number/:symbol/:
string/eof/*///+/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=
>/>/:=/;/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let
/:number/:symbol/:string/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/
:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+
/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/ne
q/=>/>/:=/=/[/(/let/:number/:symbol/:string/[/(/let/:number/:symbol/:string/*///
+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>
/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/
:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///
+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>
/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/
:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///
+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>
/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/
:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///
+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/n
eq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let
/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:
string/end/*///+/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-
/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/;/in]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 FUNCALL -> . CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:num
ber/let/(/[/;/in]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:sym
bol/:number/let/(/[/;/in]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [:=/>/=>/neq/==/<=/</-/+///*/in/
[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_19 -> . :string [:=/>/=>/neq/==/<=/</-/+///*/in/[/(/let/:number/:
symbol/:string/;]
 LALR_INTERNAL_24 -> . EXPRESSION LALR_INTERNAL_26 [in]
 LALR_INTERNAL_24 -> . [in]
 SEQUENCE -> . LALR_INTERNAL_24 [in]
GOTO(EXPRESSION) = 44
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(SEQUENCE) = 61
GOTO(LALR_INTERNAL_24) = 46
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 11
 CLOSEDEXPRESSION -> :number . [;/[/(/let/:number/:symbol/:string/eof/*///+/-/</
<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+/-/</<=/==/neq/=>/>/:
=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:num
ber/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:str
ing/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/
==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:
=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:=/=/[/(/let/:
number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:n
umber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:str
ing/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/end/*///+/-/</
<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/
;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]

Itemset 12
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)
/in/then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [eof/;/*///+/-/</<=/==/neq/=
>/>/:=/]/,/)/in/then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . :number [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 EXPRESSION -> . EXPRESSION := EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION > EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION => EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/=
=/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION == EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION < EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION - EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION + EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION / EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION * EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . FUNCALL [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///*/;/e
of]
 EXPRESSION -> . return EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-
/+///*/;/eof]
 EXPRESSION -> . goto :symbol [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///
*/;/eof]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [end/else/then/in/)/,
/]/:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> return . EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/*///+/
-/</<=/==/neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*///+/-/</<=/==/neq/=>
/>/:=/in/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/
-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/
>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq
/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==
/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<
=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-
/</<=/==/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>
/:=/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/neq/=>/>/:=/,/*///+/-/</
<=/==/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
 FUNCALL -> . CLOSEDEXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/
in/then/else/:string/:symbol/:number/let/(/[/end]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [eof/;/*///+/-/</<=/==/neq/=>/>/
:=/]/,/)/in/then/else/[/(/let/:number/:symbol/:string/end]
 LALR_INTERNAL_19 -> . :string [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/[/(/let/:number/:symbol/:string/end]
GOTO(EXPRESSION) = 60
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 13
 EXPRESSION -> goto . :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/*///+/-/</<
=/==/neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*///+/-/</<=/==/neq/=>/>/:=
/in/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<
=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/
*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>
/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/
=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/
neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=
/==/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/;
/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/neq/=>/>/:=/,/*///+/-/</<=/==
/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
GOTO(:symbol) = 59

Itemset 14
 CLOSEDEXPRESSION -> :symbol . [;/[/(/let/:number/:symbol/:string/eof/*///+/-/</
<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+/-/</<=/==/neq/=>/>/:
=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:num
ber/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:str
ing/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/
==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:
=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:=/=/[/(/let/:
number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:n
umber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:str
ing/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/end/*///+/-/</
<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/
;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]

Itemset 15
 EXPRESSION -> go . LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
]/,/*///+/-/</<=/==/neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*///+/-/</<=
/==/neq/=>/>/:=/in/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/the
n/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/
==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/<
/<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+
/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*
///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/
:=/*///+/-/</<=/==/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/=
=/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/neq/=>/>/:=/,/
*///+/-/</<=/==/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_18 -> . to [:symbol]
 LALR_INTERNAL_18 -> . [:symbol]
GOTO(LALR_INTERNAL_18) = 56
GOTO(to) = 57

Itemset 16
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [:=/>/=>/neq/==/<=/</-/+///*/then/:strin
g/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:=/>/=>/neq/==/<=/</-/+///*/then/:string/:s
ymbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:=/>/=>/neq/==/<=/</-/+///*/then/:string/:s
ymbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:=/>/=>/neq/==/<=/</-/+///*/then/:string/:s
ymbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:=/>/=>/neq/==/<=/</-/+///*
/then/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [:=/>/=>/neq/==/<=/</-/+///*/then/:string/:symbol
/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [:=/>/=>/neq/==/<=/</-/+///*/then/:string/:symbol
/:number/let/(/[/;]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/then
]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then
]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/;/then]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> if . SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
]/,/*///+/-/</<=/==/neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*///+/-/</<=
/==/neq/=>/>/:=/in/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/the
n/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/
==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/<
/<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+
/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*
///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/
:=/*///+/-/</<=/==/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/=
=/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/neq/=>/>/:=/,/
*///+/-/</<=/==/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> if . SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/]/,/*///+/-/</<=/==/neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/
;/*///+/-/</<=/==/neq/=>/>/:=/in/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/n
eq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=
/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/
>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq
/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==
/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<
=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/
*///+/-/</<=/==/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/
neq/=>/>/:=/,/*///+/-/</<=/==/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
 FUNCALL -> . CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:num
ber/let/(/[/;/then]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:sym
bol/:number/let/(/[/;/then]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [:=/>/=>/neq/==/<=/</-/+///*/the
n/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_19 -> . :string [:=/>/=>/neq/==/<=/</-/+///*/then/[/(/let/:number
/:symbol/:string/;]
 LALR_INTERNAL_24 -> . EXPRESSION LALR_INTERNAL_26 [then]
 LALR_INTERNAL_24 -> . [then]
 SEQUENCE -> . LALR_INTERNAL_24 [then]
GOTO(EXPRESSION) = 44
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(SEQUENCE) = 45
GOTO(LALR_INTERNAL_24) = 46
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 17
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:string/:symbol/:number/let
/(/[/=]
 CLOSEDEXPRESSION -> . :number [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . :symbol [:string/:symbol/:number/let/(/[/=]
 EXPRESSION -> fun . FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,
/*///+/-/</<=/==/neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*///+/-/</<=/==
/neq/=>/>/:=/in/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/then/;
/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/
neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=
/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/
</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///
+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/
*///+/-/</<=/==/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/n
eq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/neq/=>/>/:=/,/*//
/+/-/</<=/==/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
 FUNCALL -> . CLOSEDEXPRESSION [:string/:symbol/:number/let/(/[/=]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:string/:symbol/:number/let/(/[/=]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [[/(/let/:number/:symbol/:string
/=]
 LALR_INTERNAL_19 -> . :string [[/(/let/:number/:symbol/:string/=]
GOTO(FUNCALL) = 18
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(:symbol) = 14

Itemset 18
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:string/:symbol/:number/let
/(/[/=]
 CLOSEDEXPRESSION -> . :number [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . :symbol [:string/:symbol/:number/let/(/[/=]
 EXPRESSION -> fun FUNCALL . = EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 FUNCALL -> FUNCALL . CLOSEDEXPRESSION [=/[/(/let/:number/:symbol/:string]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [=/[/(/let/:number/:symbol/:stri
ng]
 LALR_INTERNAL_19 -> . :string [=/[/(/let/:number/:symbol/:string]
GOTO(CLOSEDEXPRESSION) = 19
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(:symbol) = 14
GOTO(=) = 20

Itemset 19
 FUNCALL -> FUNCALL CLOSEDEXPRESSION . [=/end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/:string/:symbol/:number/let/(/[/;/eof]

Itemset 20
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)
/in/then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [eof/;/*///+/-/</<=/==/neq/=
>/>/:=/]/,/)/in/then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . :number [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 EXPRESSION -> . EXPRESSION := EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION > EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION => EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/=
=/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION == EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION < EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION - EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION + EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION / EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION * EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . FUNCALL [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///*/;/e
of]
 EXPRESSION -> . return EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-
/+///*/;/eof]
 EXPRESSION -> . goto :symbol [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///
*/;/eof]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [end/else/then/in/)/,
/]/:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> fun FUNCALL = . EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,
/)/in/then/else/end]
 FUNCALL -> . CLOSEDEXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/
in/then/else/:string/:symbol/:number/let/(/[/end]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [eof/;/*///+/-/</<=/==/neq/=>/>/
:=/]/,/)/in/then/else/[/(/let/:number/:symbol/:string/end]
 LALR_INTERNAL_19 -> . :string [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/[/(/let/:number/:symbol/:string/end]
GOTO(EXPRESSION) = 21
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 21
 EXPRESSION -> EXPRESSION . := EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> fun FUNCALL = EXPRESSION . [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 22
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION := . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_19 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 43
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 23
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION > . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_19 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 42
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 24
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION => . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_19 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 41
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 25
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION neq . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/=
=/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_19 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 40
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 26
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION == . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_19 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 39
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 27
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION <= . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_19 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 38
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 28
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION < . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_19 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 37
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 29
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION - . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_19 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 36
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 30
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION + . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_19 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 35
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 31
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION / . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_19 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 34
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 32
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION * . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_19 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 33
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 33
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION * EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 34
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION / EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 35
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION + EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 36
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION - EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 37
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION < EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 38
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION <= EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 39
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION == EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 40
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION neq EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 41
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION => EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 42
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION > EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 43
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION := EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 44
 EXPRESSION -> EXPRESSION . := EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then
/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then/
;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then
/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/the
n/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then
/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then
/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then/
;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then/
;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then/
;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then/
;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then/
;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/<
/<=/==/neq/=>/>/:=]
 LALR_INTERNAL_24 -> EXPRESSION . LALR_INTERNAL_26 [in/then/then/end]
 LALR_INTERNAL_26 -> . ; EXPRESSION LALR_INTERNAL_26 [end/then/in]
 LALR_INTERNAL_26 -> . [end/then/in]
GOTO(LALR_INTERNAL_26) = 52
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32
GOTO(;) = 53

Itemset 45
 EXPRESSION -> if SEQUENCE . then EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> if SEQUENCE . then SEQUENCE else EXPRESSION [end/else/then/in/)/,
/]/:=/>/=>/neq/==/<=/</-/+///*/;/eof]
GOTO(then) = 47

Itemset 46
 SEQUENCE -> LALR_INTERNAL_24 . [)/in/then/then/else/end]

Itemset 47
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=
/</-/+///*/else/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-
/+///*/else/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-
/+///*/else/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-
/+///*/else/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [eof/]/,/)/in/then/end/:=/>/
=>/neq/==/<=/</-/+///*/else/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-/+///
*/else/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-/+///
*/else/:string/:symbol/:number/let/(/[/;]
 EXPRESSION -> . EXPRESSION := EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/
<=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION > EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<
=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION => EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/
<=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==
/<=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION == EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/
<=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/
<=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION < EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<
=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION - EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<
=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION + EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<
=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION / EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<
=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION * EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<
=/</-/+///*/;/else]
 EXPRESSION -> . FUNCALL [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<=/</-/+///*/;/el
se]
 EXPRESSION -> . return EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<=/</-/
+///*/;/else]
 EXPRESSION -> . goto :symbol [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<=/</-/+///*
/;/else]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [end/then/in/)/,/]/eof/:=/>/=>/neq/
==/<=/</-/+///*/;/else]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/
==/<=/</-/+///*/;/else]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [end/then/in/)/,/]/eo
f/:=/>/=>/neq/==/<=/</-/+///*/;/else]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/
<=/</-/+///*/;/else]
 EXPRESSION -> if SEQUENCE then . EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
]/,/)/in/then/else/end]
 EXPRESSION -> if SEQUENCE then . SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/]/,/)/in/then/else/end]
 FUNCALL -> . CLOSEDEXPRESSION [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-/+///
*/:string/:symbol/:number/let/(/[/;/else]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/
</-/+///*/:string/:symbol/:number/let/(/[/;/else]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [eof/]/,/)/in/then/end/:=/>/=>/n
eq/==/<=/</-/+///*/else/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_19 -> . :string [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-/+///
*/else/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_24 -> . EXPRESSION LALR_INTERNAL_26 [else]
 LALR_INTERNAL_24 -> . [else]
 SEQUENCE -> . LALR_INTERNAL_24 [else]
GOTO(EXPRESSION) = 48
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(SEQUENCE) = 49
GOTO(LALR_INTERNAL_24) = 46
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 48
 EXPRESSION -> EXPRESSION . := EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==
/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==/
neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==
/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/=
=/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==
/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==
/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==/
neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==/
neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==/
neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==/
neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==/
neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> if SEQUENCE then EXPRESSION . [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 LALR_INTERNAL_24 -> EXPRESSION . LALR_INTERNAL_26 [else]
 LALR_INTERNAL_26 -> . ; EXPRESSION LALR_INTERNAL_26 [else]
 LALR_INTERNAL_26 -> . [else]
GOTO(LALR_INTERNAL_26) = 52
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32
GOTO(;) = 53

Itemset 49
 EXPRESSION -> if SEQUENCE then SEQUENCE . else EXPRESSION [end/else/then/in/)/,
/]/:=/>/=>/neq/==/<=/</-/+///*/;/eof]
GOTO(else) = 50

Itemset 50
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)
/in/then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [eof/;/*///+/-/</<=/==/neq/=
>/>/:=/]/,/)/in/then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . :number [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 EXPRESSION -> . EXPRESSION := EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION > EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION => EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/=
=/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION == EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION < EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION - EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION + EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION / EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION * EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . FUNCALL [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///*/;/e
of]
 EXPRESSION -> . return EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-
/+///*/;/eof]
 EXPRESSION -> . goto :symbol [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///
*/;/eof]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [end/else/then/in/)/,
/]/:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> if SEQUENCE then SEQUENCE else . EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/]/,/)/in/then/else/end]
 FUNCALL -> . CLOSEDEXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/
in/then/else/:string/:symbol/:number/let/(/[/end]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [eof/;/*///+/-/</<=/==/neq/=>/>/
:=/]/,/)/in/then/else/[/(/let/:number/:symbol/:string/end]
 LALR_INTERNAL_19 -> . :string [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/[/(/let/:number/:symbol/:string/end]
GOTO(EXPRESSION) = 51
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 51
 EXPRESSION -> EXPRESSION . := EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> if SEQUENCE then SEQUENCE else EXPRESSION . [end/else/then/in/)/,
/]/:=/>/=>/neq/==/<=/</-/+///*/;/eof]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 52
 LALR_INTERNAL_24 -> EXPRESSION LALR_INTERNAL_26 . [)/else/end/then/in]

Itemset 53
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [)/;/else/end/then/:=/>/=>/neq/==/<=/</-
/+///*/:string/:symbol/:number/let/(/[/in]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [)/;/else/end/then/:=/>/=>/neq/==/<=/</-/+//
/*/:string/:symbol/:number/let/(/[/in]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [)/;/else/end/then/:=/>/=>/neq/==/<=/</-/+//
/*/:string/:symbol/:number/let/(/[/in]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [)/;/else/end/then/:=/>/=>/neq/==/<=/</-/+//
/*/:string/:symbol/:number/let/(/[/in]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [)/;/else/end/then/:=/>/=>/n
eq/==/<=/</-/+///*/:string/:symbol/:number/let/(/[/in]
 CLOSEDEXPRESSION -> . :number [)/;/else/end/then/:=/>/=>/neq/==/<=/</-/+///*/:s
tring/:symbol/:number/let/(/[/in]
 CLOSEDEXPRESSION -> . :symbol [)/;/else/end/then/:=/>/=>/neq/==/<=/</-/+///*/:s
tring/:symbol/:number/let/(/[/in]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/e
nd/else/;/)]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/en
d/else/;/)]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/e
nd/else/;/)]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/
end/else/;/)]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/e
nd/else/;/)]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/e
nd/else/;/)]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/en
d/else/;/)]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/en
d/else/;/)]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/en
d/else/;/)]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/en
d/else/;/)]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/en
d/else/;/)]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/in/then/end/else/;/)]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/end/else
/;/)]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/in/then/end/else/;/)]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/in/the
n/end/else/;/)]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/the
n/end/else/;/)]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/in/then/end/else/;/)]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/e
nd/else/;/)]
 FUNCALL -> . CLOSEDEXPRESSION [;/)/else/end/then/:=/>/=>/neq/==/<=/</-/+///*/:s
tring/:symbol/:number/let/(/[/in]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [;/)/else/end/then/:=/>/=>/neq/==/<=/</-/
+///*/:string/:symbol/:number/let/(/[/in]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [)/;/else/end/then/:=/>/=>/neq/=
=/<=/</-/+///*/[/(/let/:number/:symbol/:string/in]
 LALR_INTERNAL_19 -> . :string [)/;/else/end/then/:=/>/=>/neq/==/<=/</-/+///*/[/
(/let/:number/:symbol/:string/in]
 LALR_INTERNAL_26 -> ; . EXPRESSION LALR_INTERNAL_26 [)/else/end/then/in]
GOTO(EXPRESSION) = 54
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 54
 EXPRESSION -> EXPRESSION . := EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/
neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/n
eq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/
neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==
/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/
neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/
neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/n
eq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/n
eq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/n
eq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/n
eq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/n
eq/=>/>/:=]
 LALR_INTERNAL_26 -> . ; EXPRESSION LALR_INTERNAL_26 [else/end/then/in/)]
 LALR_INTERNAL_26 -> . [else/end/then/in/)]
 LALR_INTERNAL_26 -> ; EXPRESSION . LALR_INTERNAL_26 [)/in/then/end/else]
GOTO(LALR_INTERNAL_26) = 55
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32
GOTO(;) = 53

Itemset 55
 LALR_INTERNAL_26 -> ; EXPRESSION LALR_INTERNAL_26 . [)/else/end/then/in]

Itemset 56
 EXPRESSION -> go LALR_INTERNAL_18 . :symbol [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
GOTO(:symbol) = 58

Itemset 57
 LALR_INTERNAL_18 -> to . [:symbol]

Itemset 58
 EXPRESSION -> go LALR_INTERNAL_18 :symbol . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
]/,/)/in/then/else/end]

Itemset 59
 EXPRESSION -> goto :symbol . [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///
*/;/eof]

Itemset 60
 EXPRESSION -> EXPRESSION . := EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> return EXPRESSION . [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-
/+///*/;/eof]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 61
 CLOSEDEXPRESSION -> let SEQUENCE . in SEQUENCE end [end/else/=/then/in/)/]/,/:=
/>/=>/neq/==/<=/</-/+///*/eof/:string/:symbol/:number/let/(/[/;]
GOTO(in) = 62

Itemset 62
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [:=/>/=>/neq/==/<=/</-/+///*/end/:string
/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:=/>/=>/neq/==/<=/</-/+///*/end/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:=/>/=>/neq/==/<=/</-/+///*/end/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:=/>/=>/neq/==/<=/</-/+///*/end/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:=/>/=>/neq/==/<=/</-/+///*
/end/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [:=/>/=>/neq/==/<=/</-/+///*/end/:string/:symbol/
:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [:=/>/=>/neq/==/<=/</-/+///*/end/:string/:symbol/
:number/let/(/[/;]
 CLOSEDEXPRESSION -> let SEQUENCE in . SEQUENCE end [;/[/(/let/:number/:symbol/:
string/eof/*///+/-/</<=/==/neq/=>/>/:=/,/]/)/in/then/=/else/end]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/;/end]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 FUNCALL -> . CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:num
ber/let/(/[/;/end]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:sym
bol/:number/let/(/[/;/end]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [:=/>/=>/neq/==/<=/</-/+///*/end
/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_19 -> . :string [:=/>/=>/neq/==/<=/</-/+///*/end/[/(/let/:number/
:symbol/:string/;]
 LALR_INTERNAL_24 -> . EXPRESSION LALR_INTERNAL_26 [end]
 LALR_INTERNAL_24 -> . [end]
 SEQUENCE -> . LALR_INTERNAL_24 [end]
GOTO(EXPRESSION) = 44
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(SEQUENCE) = 63
GOTO(LALR_INTERNAL_24) = 46
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 63
 CLOSEDEXPRESSION -> let SEQUENCE in SEQUENCE . end [end/else/=/then/in/)/]/,/:=
/>/=>/neq/==/<=/</-/+///*/eof/:string/:symbol/:number/let/(/[/;]
GOTO(end) = 64

Itemset 64
 CLOSEDEXPRESSION -> let SEQUENCE in SEQUENCE end . [;/[/(/let/:number/:symbol/:
string/eof/*///+/-/</<=/==/neq/=>/>/:=/,/]/)/in/then/=/else/end]

Itemset 65
 EXPRESSION -> EXPRESSION . := EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*
///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*/
//+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*
///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/
*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*
///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*
///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*/
//+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*/
//+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*/
//+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*/
//+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*/
//+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_21 -> EXPRESSION . LALR_INTERNAL_23 [)]
 LALR_INTERNAL_23 -> . , EXPRESSION LALR_INTERNAL_23 [)]
 LALR_INTERNAL_23 -> . [)]
 LALR_INTERNAL_24 -> EXPRESSION . LALR_INTERNAL_26 [)]
 LALR_INTERNAL_26 -> . ; EXPRESSION LALR_INTERNAL_26 [)]
 LALR_INTERNAL_26 -> . [)]
GOTO(LALR_INTERNAL_23) = 71
GOTO(LALR_INTERNAL_26) = 52
GOTO(,) = 72
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32
GOTO(;) = 53

Itemset 66
 CLOSEDEXPRESSION -> ( EXPRLIST . ) [end/else/=/then/in/)/]/,/:=/>/=>/neq/==/<=/
</-/+///*/eof/:string/:symbol/:number/let/(/[/;]
GOTO()) = 70

Itemset 67
 EXPRLIST -> LALR_INTERNAL_21 . []/)]

Itemset 68
 CLOSEDEXPRESSION -> ( SEQUENCE . ) [end/else/=/then/in/)/]/,/:=/>/=>/neq/==/<=/
</-/+///*/eof/:string/:symbol/:number/let/(/[/;]
GOTO()) = 69

Itemset 69
 CLOSEDEXPRESSION -> ( SEQUENCE ) . [;/[/(/let/:number/:symbol/:string/eof/*///+
/-/</<=/==/neq/=>/>/:=/,/]/)/in/then/=/else/end]

Itemset 70
 CLOSEDEXPRESSION -> ( EXPRLIST ) . [;/[/(/let/:number/:symbol/:string/eof/*///+
/-/</<=/==/neq/=>/>/:=/,/]/)/in/then/=/else/end]

Itemset 71
 LALR_INTERNAL_21 -> EXPRESSION LALR_INTERNAL_23 . []/)]

Itemset 72
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 []/,/:=/>/=>/neq/==/<=/</-/+///*/:string
/:symbol/:number/let/(/[/)]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/:=/>/=>/neq/==/<=/</-/+///*/:string/:sy
mbol/:number/let/(/[/)]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/:=/>/=>/neq/==/<=/</-/+///*/:string/:sy
mbol/:number/let/(/[/)]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/:=/>/=>/neq/==/<=/</-/+///*/:string/:sy
mbol/:number/let/(/[/)]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/:=/>/=>/neq/==/<=/</-/+
///*/:string/:symbol/:number/let/(/[/)]
 CLOSEDEXPRESSION -> . :number []/,/:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/
:number/let/(/[/)]
 CLOSEDEXPRESSION -> . :symbol []/,/:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/
:number/let/(/[/)]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 FUNCALL -> . CLOSEDEXPRESSION [,/]/:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/
:number/let/(/[/)]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [,/]/:=/>/=>/neq/==/<=/</-/+///*/:string/
:symbol/:number/let/(/[/)]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 []/,/:=/>/=>/neq/==/<=/</-/+///*
/[/(/let/:number/:symbol/:string/)]
 LALR_INTERNAL_19 -> . :string []/,/:=/>/=>/neq/==/<=/</-/+///*/[/(/let/:number/
:symbol/:string/)]
 LALR_INTERNAL_23 -> , . EXPRESSION LALR_INTERNAL_23 []/)]
GOTO(EXPRESSION) = 73
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 73
 EXPRESSION -> EXPRESSION . := EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_23 -> . , EXPRESSION LALR_INTERNAL_23 [)/]]
 LALR_INTERNAL_23 -> . [)/]]
 LALR_INTERNAL_23 -> , EXPRESSION . LALR_INTERNAL_23 []/)]
GOTO(LALR_INTERNAL_23) = 74
GOTO(,) = 72
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 74
 LALR_INTERNAL_23 -> , EXPRESSION LALR_INTERNAL_23 . []/)]

Itemset 75
 EXPRESSION -> EXPRESSION . := EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_21 -> EXPRESSION . LALR_INTERNAL_23 []]
 LALR_INTERNAL_23 -> . , EXPRESSION LALR_INTERNAL_23 []]
 LALR_INTERNAL_23 -> . []]
GOTO(LALR_INTERNAL_23) = 71
GOTO(,) = 72
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 76
 CLOSEDEXPRESSION -> [ EXPRLIST . ] [end/else/=/then/in/)/]/,/:=/>/=>/neq/==/<=/
</-/+///*/eof/:string/:symbol/:number/let/(/[/;]
GOTO(]) = 77

Itemset 77
 CLOSEDEXPRESSION -> [ EXPRLIST ] . [;/[/(/let/:number/:symbol/:string/eof/*///+
/-/</<=/==/neq/=>/>/:=/,/]/)/in/then/=/else/end]

Itemset 78
 LALR_INTERNAL_19 -> :string LALR_INTERNAL_19 . [end/else/=/then/in/)/]/,/:=/>/=
>/neq/==/<=/</-/+///*/eof/[/(/let/:number/:symbol/:string/;]

Itemset 79
 LALR_INTERNAL_15 -> EXPRESSION LALR_INTERNAL_17 . [eof]

Itemset 80
 CLOSEDEXPRESSION -> . LALR_INTERNAL_19 [:=/>/=>/neq/==/<=/</-/+///*/eof/:string
/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:=/>/=>/neq/==/<=/</-/+///*
/eof/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:symbol/
:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:symbol/
:number/let/(/[/;]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/;/eof]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:num
ber/let/(/[/;/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:sym
bol/:number/let/(/[/;/eof]
 LALR_INTERNAL_17 -> ; . EXPRESSION LALR_INTERNAL_17 [eof]
 LALR_INTERNAL_19 -> . :string LALR_INTERNAL_19 [:=/>/=>/neq/==/<=/</-/+///*/eof
/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_19 -> . :string [:=/>/=>/neq/==/<=/</-/+///*/eof/[/(/let/:number/
:symbol/:string/;]
GOTO(EXPRESSION) = 81
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_19) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 81
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_17 -> . ; EXPRESSION LALR_INTERNAL_17 [eof]
 LALR_INTERNAL_17 -> . [eof]
 LALR_INTERNAL_17 -> ; EXPRESSION . LALR_INTERNAL_17 [eof]
GOTO(LALR_INTERNAL_17) = 82
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32
GOTO(;) = 80

Itemset 82
 LALR_INTERNAL_17 -> ; EXPRESSION LALR_INTERNAL_17 . [eof]

Itemset 83
 PROGRAM -> LALR_INTERNAL_15 eof . [$]

+++++ Reduce/reduce conflict in itemset #65 on lookahead )
Reduction #1: LALR_INTERNAL_26 -> <empty>
Reduction #2: LALR_INTERNAL_23 -> <empty>
Resolved in favour of reduction #1

+++ Shift/reduce conflict in itemset #60 on lookahead =>
Reduce: EXPRESSION -> return EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #51 on lookahead =>
Reduce: EXPRESSION -> if SEQUENCE then SEQUENCE else EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #48 on lookahead ;
Reduce: EXPRESSION -> if SEQUENCE then EXPRESSION 
Shift: to state #53
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #48 on lookahead =>
Reduce: EXPRESSION -> if SEQUENCE then EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++++ Reduce/reduce conflict in itemset #48 on lookahead else
Reduction #1: LALR_INTERNAL_26 -> <empty>
Reduction #2: EXPRESSION -> if SEQUENCE then EXPRESSION 
Resolved in favour of reduction #1

+++ Shift/reduce conflict in itemset #43 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION := EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #42 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION > EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead *
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #32
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead /
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #31
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead +
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #30
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead -
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #29
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead <
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #28
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead <=
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #27
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead ==
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #26
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead neq
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #25
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead >
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #23
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead :=
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #22
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #40 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION neq EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #39 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION == EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #38 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION <= EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #37 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION < EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #36 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION - EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #35 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION + EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #34 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION / EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #33 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION * EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #21 on lookahead =>
Reduce: EXPRESSION -> fun FUNCALL = EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++++ Reduce/reduce conflict in itemset #9 on lookahead )
Reduction #1: LALR_INTERNAL_21 -> <empty>
Reduction #2: LALR_INTERNAL_24 -> <empty>
Resolved in favour of reduction #1

+++ Shift/reduce conflict in itemset #7 on lookahead :string
Reduce: LALR_INTERNAL_19 -> :string 
Shift: to state #7
Resolved in favour of the shift operation

=== ACTION TABLE ===
STATE TERMINAL      ACTION
0     :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
1     <any>         accept
2     eof           shift to state 83
3     ;             shift to state 80
      *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #4: LALR_INTERNAL_17 -> [0 symbols] 
4     :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #22: EXPRESSION -> [1 symbols] 
5     <any>         reduce by #26: FUNCALL -> [1 symbols] 
6     <any>         reduce by #30: CLOSEDEXPRESSION -> [1 symbols] 
7     :string       shift to state 7
      <any>         reduce by #32: LALR_INTERNAL_19 -> [1 symbols] (lambda (!$1)
(list !$1))
8     :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #35: LALR_INTERNAL_21 -> [0 symbols] 
9     :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #35: LALR_INTERNAL_21 -> [0 symbols] 
10    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #40: LALR_INTERNAL_24 -> [0 symbols] 
11    <any>         reduce by #30: CLOSEDEXPRESSION -> [1 symbols] 
12    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
13    :symbol       shift to state 59
14    <any>         reduce by #30: CLOSEDEXPRESSION -> [1 symbols] 
15    to            shift to state 57
      <any>         reduce by #24: LALR_INTERNAL_18 -> [0 symbols] 
16    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #40: LALR_INTERNAL_24 -> [0 symbols] 
17    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
18    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      =             shift to state 20
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
19    <any>         reduce by #25: FUNCALL -> [2 symbols] 
20    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
21    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #10: EXPRESSION -> [4 symbols] (lambda (!$1 !$2
!$3 !$4) (list (quote fun) !$2 !$4))
22    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
23    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
24    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
25    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
26    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
27    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
28    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
29    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
30    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
31    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
32    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
33    =>            shift to state 24
      <any>         reduce by #21: EXPRESSION -> [3 symbols] (lambda (!$1 !$2
!$3) (list (quote times) !$1 !$3))
34    =>            shift to state 24
      <any>         reduce by #20: EXPRESSION -> [3 symbols] (lambda (!$1 !$2
!$3) (list (quote quotient) !$1 !$3))
35    *             shift to state 32
      /             shift to state 31
      =>            shift to state 24
      <any>         reduce by #19: EXPRESSION -> [3 symbols] (lambda (!$1 !$2
!$3) (list (quote plus) !$1 !$3))
36    *             shift to state 32
      /             shift to state 31
      =>            shift to state 24
      <any>         reduce by #18: EXPRESSION -> [3 symbols] (lambda (!$1 !$2
!$3) (list (quote difference) !$1 !$3))
37    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      =>            shift to state 24
      <any>         reduce by #17: EXPRESSION -> [3 symbols] (lambda (!$1 !$2
!$3) (list (quote lessp) !$1 !$3))
38    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      =>            shift to state 24
      <any>         reduce by #16: EXPRESSION -> [3 symbols] (lambda (!$1 !$2
!$3) (list (quote lesseq) !$1 !$3))
39    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      =>            shift to state 24
      <any>         reduce by #15: EXPRESSION -> [3 symbols] (lambda (!$1 !$2
!$3) (list (quote equals) !$1 !$3))
40    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      =>            shift to state 24
      <any>         reduce by #14: EXPRESSION -> [3 symbols] (lambda (!$1 !$2
!$3) (list (quote neq) !$1 !$3))
41    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #13: EXPRESSION -> [3 symbols] (lambda (!$1 !$2
!$3) (list (quote geq) !$1 !$3))
42    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      =>            shift to state 24
      <any>         reduce by #12: EXPRESSION -> [3 symbols] (lambda (!$1 !$2
!$3) (list (quote greaterp) !$1 !$3))
43    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #11: EXPRESSION -> [3 symbols] (lambda (!$1 !$2
!$3) (list (quote setq) !$1 !$3))
44    ;             shift to state 53
      *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #42: LALR_INTERNAL_26 -> [0 symbols] 
45    then          shift to state 47
46    <any>         reduce by #38: SEQUENCE -> [1 symbols] 
47    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #40: LALR_INTERNAL_24 -> [0 symbols] 
48    ;             shift to state 53
      *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      else          reduce by #42: LALR_INTERNAL_26 -> [0 symbols] 
      <any>         reduce by #9: EXPRESSION -> [4 symbols] (lambda (!$1 !$2 !$3
!$4) (list (quote cond) !, list (!$2 !, !$4)))
49    else          shift to state 50
50    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
51    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #8: EXPRESSION -> [6 symbols] (lambda (!$1 !$2 !$3
!$4 !$5 !$6) (list (quote cond) !, list (!$2 !, !$4) !, list (t !, !$6)))
52    <any>         reduce by #39: LALR_INTERNAL_24 -> [2 symbols] (lambda (!$1
!$2) (cons !$1 !$2))
53    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
54    ;             shift to state 53
      *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #42: LALR_INTERNAL_26 -> [0 symbols] 
55    <any>         reduce by #41: LALR_INTERNAL_26 -> [3 symbols] (lambda (!$1
!$2 !$3) (cons !$2 !$3))
56    :symbol       shift to state 58
57    <any>         reduce by #23: LALR_INTERNAL_18 -> [1 symbols] 
58    <any>         reduce by #7: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 !$3
) (list (quote go) !$3))
59    <any>         reduce by #6: EXPRESSION -> [2 symbols] (lambda (!$1 !$2) (
list (quote go) !$2))
60    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #5: EXPRESSION -> [2 symbols] 
61    in            shift to state 62
62    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #40: LALR_INTERNAL_24 -> [0 symbols] 
63    end           shift to state 64
64    <any>         reduce by #29: CLOSEDEXPRESSION -> [5 symbols] (lambda (!$1
!$2 !$3 !$4 !$5) (list (quote letstat) !$2 !$4))
65    ;             shift to state 53
      *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      ,             shift to state 72
      <any>         reduce by #42: LALR_INTERNAL_26 -> [0 symbols] 
66    )             shift to state 70
67    <any>         reduce by #33: EXPRLIST -> [1 symbols] 
68    )             shift to state 69
69    <any>         reduce by #28: CLOSEDEXPRESSION -> [3 symbols] (lambda (!$1
!$2 !$3) (cons (quote paren) !$2))
70    <any>         reduce by #28: CLOSEDEXPRESSION -> [3 symbols] (lambda (!$1
!$2 !$3) (cons (quote paren) !$2))
71    <any>         reduce by #34: LALR_INTERNAL_21 -> [2 symbols] (lambda (!$1
!$2) (cons !$1 !$2))
72    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
73    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      ,             shift to state 72
      <any>         reduce by #37: LALR_INTERNAL_23 -> [0 symbols] 
74    <any>         reduce by #36: LALR_INTERNAL_23 -> [3 symbols] (lambda (!$1
!$2 !$3) (cons !$2 !$3))
75    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      ,             shift to state 72
      <any>         reduce by #37: LALR_INTERNAL_23 -> [0 symbols] 
76    ]             shift to state 77
77    <any>         reduce by #27: CLOSEDEXPRESSION -> [3 symbols] (lambda (!$1
!$2 !$3) (cons (quote bracket) !$2))
78    <any>         reduce by #31: LALR_INTERNAL_19 -> [2 symbols] (lambda (!$1
!$2) (cons !$1 !$2))
79    <any>         reduce by #2: LALR_INTERNAL_15 -> [2 symbols] (lambda (!$1
!$2) (cons !$1 !$2))
80    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
81    ;             shift to state 80
      *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #4: LALR_INTERNAL_17 -> [0 symbols] 
82    <any>         reduce by #3: LALR_INTERNAL_17 -> [3 symbols] (lambda (!$1
!$2 !$3) (cons !$2 !$3))
83    <any>         reduce by #1: PROGRAM -> [2 symbols] (lambda (!$1 !$2) !$1)

=== GOTO TABLE ===
NONTERMINAL         SRC     DEST
PROGRAM             <any>   1
LALR_INTERNAL_15    <any>   2
LALR_INTERNAL_17    81      82
                    <any>   79
EXPRESSION          0       3
                    20      21
                    32      33
                    31      34
                    30      35
                    29      36
                    28      37
                    27      38
                    26      39
                    25      40
                    24      41
                    23      42
                    22      43
                    47      48
                    50      51
                    53      54
                    12      60
                    9       65
                    72      73
                    8       75
                    80      81
                    <any>   44
LALR_INTERNAL_18    <any>   56
FUNCALL             17      18
                    <any>   4
CLOSEDEXPRESSION    18      19
                    4       19
                    <any>   5
LALR_INTERNAL_19    7       78
                    <any>   6
EXPRLIST            8       76
                    <any>   66
LALR_INTERNAL_21    <any>   67
LALR_INTERNAL_23    73      74
                    <any>   71
SEQUENCE            47      49
                    10      61
                    62      63
                    9       68
                    <any>   45
LALR_INTERNAL_24    <any>   46
LALR_INTERNAL_26    54      55
                    <any>   52


(((nil 35 . !,) (nil 34 . !]) (nil 33 . ![) (nil 32 . !)) (nil 31 . !() (nil 30
. end) (nil 29 . in) (nil 28 . let) (nil 27 . to) (nil 26 . return) (nil 25 .
goto) (nil 24 . go) (nil 23 . else) (nil 22 . then) (nil 21 . if) (nil 20 . fun)
(((!= . !:!=)) 19 . !:) (nil 18 . !:!=) (nil 17 . !>) (nil 16 . !=!>) (nil 15 .
neq) (((!> . !=!>) (!= . !=!=)) 14 . !=) (nil 13 . !=!=) (nil 12 . !<!=) (((!= .
!<!=)) 11 . !<) (nil 10 . !-) (nil 9 . !+) (nil 8 . !/) (nil 7 . !*) (nil 6 . !;
) (nil 5 . eof) (nil 0 . !:eof) (nil 1 . !:symbol) (nil 2 . !:string) (nil 3 .
!:number) (nil 4 . !:list)) [(((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24
. 15) (25 . 13) (26 . 12) (28 . 10) (31 . 9) (33 . 8))) (nil . 0) (((5 . 83))) (
((6 . 80) (7 . 32) (8 . 31) (9 . 30) (10 . 29) (11 . 28) (12 . 27) (13 . 26) (15
. 25) (16 . 24) (17 . 23) (18 . 22)) . -4) (((1 . 14) (2 . 7) (3 . 11) (28 . 10)
(31 . 9) (33 . 8)) . -22) (nil . -26) (nil . -30) (((2 . 7)) . -32) (((1 . 14) (
2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15) (25 . 13) (26 . 12) (28 . 10) (31
. 9) (33 . 8)) . -35) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15)
(25 . 13) (26 . 12) (28 . 10) (31 . 9) (33 . 8)) . -35) (((1 . 14) (2 . 7) (3 .
11) (20 . 17) (21 . 16) (24 . 15) (25 . 13) (26 . 12) (28 . 10) (31 . 9) (33 . 8
)) . -40) (nil . -30) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15)
(25 . 13) (26 . 12) (28 . 10) (31 . 9) (33 . 8))) (((1 . 59))) (nil . -30) (((27
. 57)) . -24) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15) (25 . 13
) (26 . 12) (28 . 10) (31 . 9) (33 . 8)) . -40) (((1 . 14) (2 . 7) (3 . 11) (28
. 10) (31 . 9) (33 . 8))) (((1 . 14) (2 . 7) (3 . 11) (14 . 20) (28 . 10) (31 .
9) (33 . 8))) (nil . -25) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 .
15) (25 . 13) (26 . 12) (28 . 10) (31 . 9) (33 . 8))) (((7 . 32) (8 . 31) (9 .
30) (10 . 29) (11 . 28) (12 . 27) (13 . 26) (15 . 25) (16 . 24) (17 . 23) (18 .
22)) . -10) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15) (25 . 13)
(26 . 12) (28 . 10) (31 . 9) (33 . 8))) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (
21 . 16) (24 . 15) (25 . 13) (26 . 12) (28 . 10) (31 . 9) (33 . 8))) (((1 . 14)
(2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15) (25 . 13) (26 . 12) (28 . 10) (31
. 9) (33 . 8))) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15) (25 .
13) (26 . 12) (28 . 10) (31 . 9) (33 . 8))) (((1 . 14) (2 . 7) (3 . 11) (20 . 17
) (21 . 16) (24 . 15) (25 . 13) (26 . 12) (28 . 10) (31 . 9) (33 . 8))) (((1 .
14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15) (25 . 13) (26 . 12) (28 . 10)
(31 . 9) (33 . 8))) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15) (
25 . 13) (26 . 12) (28 . 10) (31 . 9) (33 . 8))) (((1 . 14) (2 . 7) (3 . 11) (20
. 17) (21 . 16) (24 . 15) (25 . 13) (26 . 12) (28 . 10) (31 . 9) (33 . 8))) (((1
. 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15) (25 . 13) (26 . 12) (28 .
10) (31 . 9) (33 . 8))) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15
) (25 . 13) (26 . 12) (28 . 10) (31 . 9) (33 . 8))) (((1 . 14) (2 . 7) (3 . 11)
(20 . 17) (21 . 16) (24 . 15) (25 . 13) (26 . 12) (28 . 10) (31 . 9) (33 . 8)))
(((16 . 24)) . -21) (((16 . 24)) . -20) (((7 . 32) (8 . 31) (16 . 24)) . -19) ((
(7 . 32) (8 . 31) (16 . 24)) . -18) (((7 . 32) (8 . 31) (9 . 30) (10 . 29) (16 .
24)) . -17) (((7 . 32) (8 . 31) (9 . 30) (10 . 29) (16 . 24)) . -16) (((7 . 32)
(8 . 31) (9 . 30) (10 . 29) (16 . 24)) . -15) (((7 . 32) (8 . 31) (9 . 30) (10 .
29) (16 . 24)) . -14) (((7 . 32) (8 . 31) (9 . 30) (10 . 29) (11 . 28) (12 . 27)
(13 . 26) (15 . 25) (16 . 24) (17 . 23) (18 . 22)) . -13) (((7 . 32) (8 . 31) (9
. 30) (10 . 29) (16 . 24)) . -12) (((7 . 32) (8 . 31) (9 . 30) (10 . 29) (11 .
28) (12 . 27) (13 . 26) (15 . 25) (16 . 24) (17 . 23) (18 . 22)) . -11) (((6 .
53) (7 . 32) (8 . 31) (9 . 30) (10 . 29) (11 . 28) (12 . 27) (13 . 26) (15 . 25)
(16 . 24) (17 . 23) (18 . 22)) . -42) (((22 . 47))) (nil . -38) (((1 . 14) (2 .
7) (3 . 11) (20 . 17) (21 . 16) (24 . 15) (25 . 13) (26 . 12) (28 . 10) (31 . 9)
(33 . 8)) . -40) (((6 . 53) (7 . 32) (8 . 31) (9 . 30) (10 . 29) (11 . 28) (12 .
27) (13 . 26) (15 . 25) (16 . 24) (17 . 23) (18 . 22) (23 . -42)) . -9) (((23 .
50))) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15) (25 . 13) (26 .
12) (28 . 10) (31 . 9) (33 . 8))) (((7 . 32) (8 . 31) (9 . 30) (10 . 29) (11 .
28) (12 . 27) (13 . 26) (15 . 25) (16 . 24) (17 . 23) (18 . 22)) . -8) (nil .
-39) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15) (25 . 13) (26 .
12) (28 . 10) (31 . 9) (33 . 8))) (((6 . 53) (7 . 32) (8 . 31) (9 . 30) (10 . 29
) (11 . 28) (12 . 27) (13 . 26) (15 . 25) (16 . 24) (17 . 23) (18 . 22)) . -42)
(nil . -41) (((1 . 58))) (nil . -23) (nil . -7) (nil . -6) (((7 . 32) (8 . 31) (
9 . 30) (10 . 29) (11 . 28) (12 . 27) (13 . 26) (15 . 25) (16 . 24) (17 . 23) (
18 . 22)) . -5) (((29 . 62))) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (
24 . 15) (25 . 13) (26 . 12) (28 . 10) (31 . 9) (33 . 8)) . -40) (((30 . 64))) (
nil . -29) (((6 . 53) (7 . 32) (8 . 31) (9 . 30) (10 . 29) (11 . 28) (12 . 27) (
13 . 26) (15 . 25) (16 . 24) (17 . 23) (18 . 22) (35 . 72)) . -42) (((32 . 70)))
(nil . -33) (((32 . 69))) (nil . -28) (nil . -28) (nil . -34) (((1 . 14) (2 . 7)
(3 . 11) (20 . 17) (21 . 16) (24 . 15) (25 . 13) (26 . 12) (28 . 10) (31 . 9) (
33 . 8))) (((7 . 32) (8 . 31) (9 . 30) (10 . 29) (11 . 28) (12 . 27) (13 . 26) (
15 . 25) (16 . 24) (17 . 23) (18 . 22) (35 . 72)) . -37) (nil . -36) (((7 . 32)
(8 . 31) (9 . 30) (10 . 29) (11 . 28) (12 . 27) (13 . 26) (15 . 25) (16 . 24) (
17 . 23) (18 . 22) (35 . 72)) . -37) (((34 . 77))) (nil . -27) (nil . -31) (nil
. -2) (((1 . 14) (2 . 7) (3 . 11) (20 . 17) (21 . 16) (24 . 15) (25 . 13) (26 .
12) (28 . 10) (31 . 9) (33 . 8))) (((6 . 80) (7 . 32) (8 . 31) (9 . 30) (10 . 29
) (11 . 28) (12 . 27) (13 . 26) (15 . 25) (16 . 24) (17 . 23) (18 . 22)) . -4) (
nil . -3) (nil . -1)] ([nil action0030 action0031 action0032 nil nil action0033
action0034 action0035 action0036 action0037 action0038 action0039 action0040
action0041 action0042 action0043 action0044 action0045 action0046 action0047
action0048 nil nil nil nil nil action0049 action0050 action0051 nil action0052
action0053 nil action0054 nil action0055 nil nil action0056 nil action0057 nil]
#V8(1 2 2 3 0 2 2 3 6 4 4 3 3 3 3 3 3 3 3 3 3 3 1 1 0 2 1 3 3 5 1 2 1 1 2 0 3 0
1 2 0 3 0 0) #V16(-1 0 1 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 5 5 6 6 6 6
7 7 8 9 9 10 10 11 12 12 13 13 0 27698 0 0)) [(nil . 1) (nil . 2) (((81 . 82)) .
79) (((0 . 3) (20 . 21) (32 . 33) (31 . 34) (30 . 35) (29 . 36) (28 . 37) (27 .
38) (26 . 39) (25 . 40) (24 . 41) (23 . 42) (22 . 43) (47 . 48) (50 . 51) (53 .
54) (12 . 60) (9 . 65) (72 . 73) (8 . 75) (80 . 81)) . 44) (nil . 56) (((17 . 18
)) . 4) (((18 . 19) (4 . 19)) . 5) (((7 . 78)) . 6) (((8 . 76)) . 66) (nil . 67)
(((73 . 74)) . 71) (((47 . 49) (10 . 61) (62 . 63) (9 . 68)) . 45) (nil . 46) ((
(54 . 55)) . 52) nil] ((-1 . !S!') (13 . lalr_internal_26) (12 .
lalr_internal_24) (11 . sequence) (10 . lalr_internal_23) (9 . lalr_internal_21)
(8 . exprlist) (7 . lalr_internal_19) (6 . closedexpression) (5 . funcall) (4 .
lalr_internal_18) (3 . expression) (2 . lalr_internal_17) (1 . lalr_internal_15)
(0 . program) (-1 . !S!') (1 . cc) (0 . s)) ((35 . !,) (34 . !]) (33 . ![) (32 .
!)) (31 . !() (30 . end) (29 . in) (28 . let) (27 . to) (26 . return) (25 . goto
) (24 . go) (23 . else) (22 . then) (21 . if) (20 . fun) (19 . !:) (18 . !:!=) (
17 . !>) (16 . !=!>) (15 . neq) (14 . !=) (13 . !=!=) (12 . !<!=) (11 . !<) (10
. !-) (9 . !+) (8 . !/) (7 . !*) (6 . !;) (5 . eof) (4 . !:list) (3 . !:number)
(2 . !:string) (1 . !:symbol) (0 . !:eof)))


pparse g$

yylex initialized

fun 
yylex = fun type 20
Shift token 20 onto stack, and shift to state 17
f(
yylex = f type 1
Shift token f onto stack, and shift to state 14
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 18
yylex = !( type 31
Shift token 31 onto stack, and shift to state 9
a,
yylex = a type 1
Shift token a onto stack, and shift to state 14
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
yylex = !, type 35
On lookahead 35, reduce 1 symbols to nonterminal EXPRESSION, and goto state 65
Shift token 35 onto stack, and shift to state 72
b)
yylex = b type 1
Shift token b onto stack, and shift to state 14
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
yylex = !) type 32
On lookahead 32, reduce 1 symbols to nonterminal EXPRESSION, and goto state 73
On lookahead 32, reduce 0 symbols to nonterminal LALR_INTERNAL_23
, and goto state 74
On lookahead 32, reduce 3 symbols to nonterminal LALR_INTERNAL_23
, and goto state 71
On lookahead 32, reduce 2 symbols to nonterminal LALR_INTERNAL_21
, and goto state 67
On lookahead 32, reduce 1 symbols to nonterminal EXPRLIST, and goto state 66
Shift token 32 onto stack, and shift to state 70
On lookahead -1, reduce 3 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 19
On lookahead -1, reduce 2 symbols to nonterminal FUNCALL, and goto state 18
 = 
yylex = != type 14
Shift token 14 onto stack, and shift to state 20
a 
yylex = a type 1
Shift token a onto stack, and shift to state 14
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
+
yylex = !+ type 9
On lookahead 9, reduce 1 symbols to nonterminal EXPRESSION, and goto state 21
Shift token 9 onto stack, and shift to state 30
 b;
yylex = b type 1
Shift token b onto stack, and shift to state 14
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
yylex = !; type 6
On lookahead 6, reduce 1 symbols to nonterminal EXPRESSION, and goto state 35
On lookahead 6, reduce 3 symbols to nonterminal EXPRESSION, and goto state 21
On lookahead 6, reduce 4 symbols to nonterminal EXPRESSION, and goto state 3
Shift token 6 onto stack, and shift to state 80

f(
yylex = f type 1
Shift token f onto stack, and shift to state 14
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
yylex = !( type 31
Shift token 31 onto stack, and shift to state 9
22,
yylex = 22 type 3
Shift token 22 onto stack, and shift to state 11
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
yylex = !, type 35
On lookahead 35, reduce 1 symbols to nonterminal EXPRESSION, and goto state 65
Shift token 35 onto stack, and shift to state 72
33)
yylex = 33 type 3
Shift token 33 onto stack, and shift to state 11
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
yylex = !) type 32
On lookahead 32, reduce 1 symbols to nonterminal EXPRESSION, and goto state 73
On lookahead 32, reduce 0 symbols to nonterminal LALR_INTERNAL_23
, and goto state 74
On lookahead 32, reduce 3 symbols to nonterminal LALR_INTERNAL_23
, and goto state 71
On lookahead 32, reduce 2 symbols to nonterminal LALR_INTERNAL_21
, and goto state 67
On lookahead 32, reduce 1 symbols to nonterminal EXPRLIST, and goto state 66
Shift token 32 onto stack, and shift to state 70
On lookahead -1, reduce 3 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 19
On lookahead -1, reduce 2 symbols to nonterminal FUNCALL, and goto state 4

eof
yylex = eof type 5
On lookahead 5, reduce 1 symbols to nonterminal EXPRESSION, and goto state 81
On lookahead 5, reduce 0 symbols to nonterminal LALR_INTERNAL_17
, and goto state 82
On lookahead 5, reduce 3 symbols to nonterminal LALR_INTERNAL_17
, and goto state 79
On lookahead 5, reduce 2 symbols to nonterminal LALR_INTERNAL_15
, and goto state 2
Shift token 5 onto stack, and shift to state 83
On lookahead -1, reduce 2 symbols to nonterminal PROGRAM, and goto state 1
Seems to have finished... 
= ((fun (f (paren a b)) (plus a b)) (f (paren then ![)))

end;

nil
