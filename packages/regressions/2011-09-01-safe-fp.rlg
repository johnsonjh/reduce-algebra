on rounded;



% In 2011 this tested safe!-fp!-plus etc.

% As of 2020 things have changed and the new model is that safe!-fp!-op
% performs X op Y and if the result is an infinity or a NaN it returns nil
% without generating an exception. So my newer "reference" implementation
% here tried to model that, and is probably exactly the code used with PSL!



lisp;


nil


on echo,comp;


nil

% The procedures here will be compiled, but I switch off all
% compiler messages because those messages are platform dependent
% and so would show up as gratuitous differences between the log files
% on differing machines.

load compiler;


nil

off pwrds;


nil


errs := 0;


0


maxx := 1.797e+308;


1.797e+308


list(!!plumin,
     !!plumax,
     !!timmin,
     !!timmax);


(4.45015e-296 2.24712e+307 2.10954e-154 4.74038e+153)


ll := v := nil;


nil

for i := 0:20 do <<
   w := expt(1.12345, i);
   v := w . (1.0/w) . v;
   v := (!!plumin*w) . (!!plumin/w) . v;
   if w < maxx/!!plumax then
     v := (!!plumax*w) . (!!plumax/w) . v;
   v := (!!timmin*w) . (!!timmax/w) . v
   >>;


nil


v;


(2.16402e-153 4.62102e+152 4.56509e-295 4.3381e-297 10.2583 0.0974821 
1.92623e-153 5.19148e+152 4.06346e-295 4.87364e-297 9.13106 0.109516 
1.71457e-153 5.83237e+152 3.61694e-295 5.47529e-297 8.1277 0.123036 1.52616e-153
6.55238e+152 1.6257e+308 3.10607e+306 3.2195e-295 6.15121e-297 7.23459 0.138225
1.35846e-153 7.36127e+152 1.44706e+308 3.48952e+306 2.86572e-295 6.91058e-297 
6.43962 0.155289 1.20919e-153 8.27002e+152 1.28805e+308 3.9203e+306 2.55082e-295
7.76369e-297 5.732 0.174459 1.07632e-153 9.29095e+152 1.14651e+308 4.40426e+306
2.27053e-295 8.72212e-297 5.10214 0.195996 9.58045e-154 1.04379e+153 
1.02053e+308 4.94797e+306 2.02103e-295 9.79886e-297 4.54149 0.220192 
8.52771e-154 1.17265e+153 9.08386e+307 5.55879e+306 1.79895e-295 1.10085e-296 
4.04245 0.247375 7.59064e-154 1.31741e+153 8.08568e+307 6.24503e+306 
1.60127e-295 1.23675e-296 3.59825 0.277913 6.75655e-154 1.48005e+153 
7.19719e+307 7.01598e+306 1.42532e-295 1.38943e-296 3.20286 0.312221 6.0141e-154
1.66276e+153 6.40633e+307 7.8821e+306 1.2687e-295 1.56096e-296 2.85091 0.350765
5.35325e-154 1.86803e+153 5.70237e+307 8.85514e+306 1.12929e-295 1.75366e-296 
2.53764 0.394067 4.76501e-154 2.09863e+153 5.07577e+307 9.94831e+306 1.0052e-295
1.97014e-296 2.25879 0.442715 4.2414e-154 2.35771e+153 4.51802e+307 1.11764e+307
8.9474e-296 2.21336e-296 2.01059 0.497368 3.77534e-154 2.64877e+153 4.02156e+307
1.25562e+307 7.96422e-296 2.4866e-296 1.78965 0.558768 3.36049e-154 2.97576e+153
3.57965e+307 1.41062e+307 7.08907e-296 2.79357e-296 1.593 0.627748 2.99122e-154
3.34312e+153 3.1863e+307 1.58476e+307 6.31009e-296 3.13844e-296 1.41795 0.705243
2.66253e-154 3.75582e+153 2.83618e+307 1.7804e+307 5.61671e-296 3.52588e-296 
1.26214 0.792305 2.36996e-154 4.21948e+153 2.52452e+307 2.00019e+307 
4.99952e-296 3.96114e-296 1.12345 0.890115 2.10954e-154 4.74038e+153 
2.24712e+307 2.24712e+307 4.45015e-296 4.45015e-296 1.0 1.0)


for each x in v do
  ll := x . (-x) . ll;


nil


% ll is now a list of critical values

length ll;


324


fluid '(errs);


nil


symbolic procedure badcase();
  errs := errs + 1;


badcase



global '(!!maxfloatq2 !!two511 !!two513);


nil


remprop('!!maxfloatq2, 'constant!?);


8.98847e+307

remprop('!!two511, 'constant!?);


6.7039e+153

remprop ('!!two513, 'constant!?);


2.68156e+154


begin
  scalar r, w;
% I know the numeric value I want expressed in powers of 2, so I compute
% it here building on initial values that are small enough that I can
% be confident that they read in exactly.
  r := 8388608.0;
  w := r*r*r;
  r := r*w*w;
  r := r*r*r;
  r := 8.0*r*r;
% The value I produce here is 2^53-1 times a huge power of 2 and is the
% largest finite IEEE double precision value.
  !!maxfloatq2 := r*(134217728.0*134217728.0-2.0);
  r := 2.0;
  for i := 1:9 do r := r*r;
  !!two511 := r/2.0;
  !!two513 := 2.0*r
end;


nil


put('!!maxfloatq2, 'constant!?, !!maxfloatq2);


8.98847e+307

put('!!two511, 'constant!?, !!two511);


6.7039e+153

put('!!two513, 'constant!?, !!two513);


2.68156e+154


symbolic procedure portable!-fp!-plus(u, v);
% I can only get overflow if u and v have the same sign. If u and
% v are normalised to start with I can only end up with a sub-normal
% number if their signs differ. Note that both +0.0 and -0.0 count as >= 0.0
% and so do not go through the code that checks for underflow.
  if u < 0.0 then
    if v < 0.0 then <<
% I want to see if u+v > would overflow. If u and v are large then I can
% compute u/2 and v/2 with no loss of anything (if say u/2 was sub-normal
% it might lose accuracy here). In this case both operands are negative
% so comparing against half the most negative possible value does the
% checking that I need. It I pass this test it will be safe to perform
% a simple addition.
      if 0.5*u + 0.5*v < -!!maxfloatq2 then nil
      else u + v >>
    else begin
% u and v have different signs, so adding them can not lead to overflow
% but might result in underflow. So do the arithmetic directly and check.
      scalar r;
      r := u + v;
      if r = 0.0 then return r
       else if r < !!minnorm and r > !!minnegnorm then return nil
% As in the CSL case I dislike and would like to remove this next line.
% Note that in the CSL case I only make this extra test if u and v have
% different signs. The calculation performed can never cause an overflow!
% This premature underflow to 0.0 just loses accuracy in a way I find
% really disturbing, but I am leaving the behaviour here as it is for
% compatibility with older versions of the code.
      else if u - r*0.001953125 = u then return 0.0
      else return r
    end
  else if v < 0.0 then begin
% A second case where signs differ. When writing this I felt that the
% duplicated code here was ugly but that adjusting the tree of tests to
% have just one copy of this led to worse mess.
    scalar r;
    r := u + v;
    if r = 0.0 then return r
     else if r < !!minnorm and r > !!minnegnorm then return nil
    else if u - r*0.001953125 = u then return 0.0
    else return r
  end
  else <<
% Adding two positive values.
    if 0.5*u + 0.5*v > !!maxfloatq2 then nil
    else u + v >>;


portable!-fp!-plus


symbolic procedure portable!-fp!-times(u, v);
  begin
% Now the real business. I will have essentially three cases, based on
% the magnitude of the numbers.
% (a) numbers are big and I may risk overflow.
% (b) numbers are small and I may risk underflow.
% (c) numbers are such that I have no great risk.
    scalar u1, v1;
    if !*nonegzerotimes and (u = 0.0 or v = 0.0) then return 0.0;
    if u < 0.0 then u1 := -u else u1 := u;
    if v < 0.0 then v1 := -v else v1 := v;
% I now have the absolute values of the operands. I will check for all
% potential bad cases.
    if u1 < !!two511 then
      if v1 < !!two511 then <<
% Here both numbers are fairly small, so I can afford to multiply them
% directly. Since I have filtered out multiplication by zero I can then
% detect (gradual) underflow with a simple comparison.
        if u1*v1 < !!minnorm and u neq 0.0 and v neq 0.0 then return nil >>
      else <<
% Here u is small but v is big. If I divide v by 2^511 it ends up in the
% range 1 to 2^513, and in particular multiplying by u will not overflow.
% Furthermore it can not underflow either because (v/2^511) is at least 1.0.
        if u1*(v1/!!two511) >= !!two513 then return nil >>
    else if v1 < !!two511 then <<
% Here u is large but v is not... so similar arguments apply.
      if (u1/!!two511)*v1 >= !!two513 then return nil >>
    else <<
% Finally both u and v are greater than or equal to 2^511 so overflow is possible.
      if (u1/!!two511)*(v1/!!two511) >= 4.0 then return nil >>;
    return u*v
  end;


portable!-fp!-times


symbolic procedure portable!-fp!-quot(u, v);
% The logic for division is essentially the same as that for multiplication.
  if v = 0.0 then nil
  else begin
    scalar u1, v1;
    if !*nonegzerotimes and u = 0.0 then return 0.0;
    if u < 0.0 then u1 := -u else u1 := u;
    if v < 0.0 then v1 := -v else v1 := v;
% I now have the absolute values of the operands.
    if u1 < !!two511 then
      if v1 > 1.0/!!two511 then <<
% Divide a not huge number by a not tiny one, so quotient will not
% overflow, but could underflow.
        if u1/v1 < !!minnorm and u neq 0.0 then return nil >>
      else <<
% Here u is reasonable but v is tiny.
        if u1/(v1*!!two511) >= !!two513 then return nil >>
    else if v1 > 1.0/!!two511 then <<
% Here u is large but v is not too tiny...
      if (u1/!!two511)/v1 >= !!two513 then return nil >>
    else <<
% Finally u is big and v is tiny...
      if (u1/!!two511)/(v1*!!two511) >= 4.0 then return nil >>;
    return u/v;
  end;


portable!-fp!-quot

    



symbolic procedure tab_to n;
  while posn() < n do prin2 " ";


tab_to


for each x in ll do
  for each y in ll do <<
     if errs < 20 then <<
        a1 := safe!-fp!-plus(x, y);
        a2 := portable!-fp!-plus(x, y);
        if not eqn(a1, a2) then <<
            terpri();
            prin2t "safe-fp-plus incorrect";
            prin2 "x: "; prin2 x; tab_to 40; prin2t hexfloat1 x;
            prin2 "y: "; prin2 y; tab_to 40; prin2t hexfloat1 y;
            prin2 "new: "; prin2 a1; tab_to 40; prin2t hexfloat1 a1;
            prin2 "ref: "; prin2 a2; tab_to 40; prin2t hexfloat1 a2;
            terpri();
            badcase() >>;
        a1 := safe!-fp!-times(x, y);
        a2 := portable!-fp!-times(x, y);
        if not eqn(a1, a2) then <<
            terpri();
            prin2t "safe-fp-times incorrect";
            prin2 "x: "; prin2 x; tab_to 40; prin2t hexfloat1 x;
            prin2 "y: "; prin2 y; tab_to 40; prin2t hexfloat1 y;
            prin2 "new: "; prin2 a1; tab_to 40; prin2t hexfloat1 a1;
            prin2 "ref: "; prin2 a2; tab_to 40; prin2t hexfloat1 a2;
            terpri();
            badcase() >>;
        a1 := safe!-fp!-quot(x, y);
        a2 := portable!-fp!-quot(x, y);
        if not eqn(a1, a2) then <<
            terpri();
            prin2t "safe-fp-quot incorrect";
            prin2 "x: "; prin2 x; tab_to 40; prin2t hexfloat1 x;
            prin2 "y: "; prin2 y; tab_to 40; prin2t hexfloat1 y;
            prin2 "new: "; prin2 a1; tab_to 40; prin2t hexfloat1 a1;
            prin2 "ref: "; prin2 a2; tab_to 40; prin2t hexfloat1 a2;
            terpri();
            badcase() >> >> >>;

***** Floating point error in ftimes2



end;

nil
